[{"title":"深入理解Android中Handler机制","date":"2017-03-10T08:20:09.000Z","path":"2017/03/10/深入理解Android中Handler机制/","text":"对于一位Android开发者来说，对Handler、Looper、Message三个乖宝贝应该再熟悉不过了，这里我们先简单介绍下这三者的关系，之后再用Looper.loop方法做点有意思的事情，加深对运行循环的理解。 一、源码理解Handler、Looper、Message通常我们在使用Handler时会在主线程中new出一个Handler来接收消息，我们来看下Handler源码：12345678910/** * Default constructor associates this handler with the &#123;@link Looper&#125; for the * current thread. * * If this thread does not have a looper, this handler won&apos;t be able to receive messages * so an exception is thrown. */ public Handler() &#123; this(null, false); &#125; 在源码注释中说到默认的构造方法创建Handler，会从当前线程中取出Looper，如果当前线程没有Looper，这个Handler不能够接收到消息并会抛出异常。我们继续点进去：12345678910111213141516171819public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); &#125; &#125; //获取Looper mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; 1234567/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */ public static Looper myLooper() &#123; return sThreadLocal.get();//从ThreadLocal中获取 &#125; 既然Looper是从ThreadLocal中获取的，那必然有时机要存进去，我们看下Looper是什么时候存进去的：12345678910111213141516/** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */ public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; 也就是说我们在调用Looper. prepare方法时会创建Looper并存入ThreadLocal中，注意默认quitAllowed参数都为true，也就是默认创建的Looper都是可以退出的，我们可以点进去看看：12345678910private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125;//进去MessageQueue.java MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit(); &#125; ⚠️注意：MessageQueue的成员变量mQuitAllowed，在调用Looper.quit方法时会进入MessageQueue对mQuitAllowed进行判断，可以简单看下源码，后面会再说到:1234567891011121314151617181920212223//MessageQueue.javavoid quit(boolean safe) &#123; //如果mQuitAllowed为false，也就是不允许退出时会报出异常 if (!mQuitAllowed) &#123; throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;); &#125; synchronized (this) &#123; if (mQuitting) &#123; return; &#125; mQuitting = true; if (safe) &#123; removeAllFutureMessagesLocked(); &#125; else &#123; removeAllMessagesLocked(); &#125; // We can assume mPtr != 0 because mQuitting was previously false. nativeWake(mPtr); &#125; &#125; 看到这里我们应该是有疑问的， 第一个疑问：默认我们调用Looper.prepare方法时mQuitAllowed变量都为true的，那它什么时候为false?又是被如何设为false的？ 第二个疑问：我们在创建Handler时，并没有往ThreadLocal中存Looper，而却直接就取出了ThreadLocal中的Looper，那么这个Looper是什么时候创建并存入的？ 这里就要说到ActivityThread中main方法了。Zygote进程孵化出新的应用进程后，会执行ActivityThread类的main方法。在该方法里会先准备好Looper和消息队列，并将Looper存入ThreadLocal中，然后调用attach方法将应用进程绑定到ActivityManagerService，然后进入loop循环，不断地读取消息队列里的消息，并分发消息。 1234567891011121314151617181920212223242526272829303132333435363738//ActivityThread public static void main(String[] args) &#123; SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); //创建主线程的阻塞队列 Looper.prepareMainLooper(); // 创建ActivityThread实例 ActivityThread thread = new ActivityThread(); //执行初始化 thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; AsyncTask.init(); if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; //开启循环 Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); &#125; 我们看下开启的loop循环吧：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; //注意这里 msg.target为发送msg的Handler msg.target.dispatchMessage(msg); if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn&apos;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; msg.recycleUnchecked(); &#125; &#125; Looper.loop方法内部是个死循环(for(;;))。queue.next();是从阻塞队列里取走头部的Message，当没有Message时主线程就会阻塞。view绘制，事件分发，activity启动，activity的生命周期回调等等都是一个个的Message，系统会把这些Message插入到主线程中唯一的queue中，所有的消息都排队等待主线程的执行。回过来我们捋一下思路，首先，我们在主线程中创建了Handler，在Handler的构造方法中会判断是否创建了Looper，由于在ActivityThread.main方法中我们初始化了Looper并将其存入ThreadLocal中，所以可以正常创建Handler。（而如果不是在主线程中创建Handler，则需要在创建之前手动调用Looper.prepare方法。）在Looper的构造方法中创建了MessageQueue消息队列用于存取Message。然后，Handler.sendMessage发送消息，在queue.enqueueMessage(msg, uptimeMillis)方法中将Message存入MessageQueue中，并最终在Loop.loop循环中取出消息调用msg.target.dispatchMessage(msg);也就是发送消息的Handler的dispatchMessage方法处理消息，在dispatchMessage最终调用了handleMessage(msg);方法。这样我们就可以正常处理发送到主线程的消息了。 二、用Looper搞事情 异步任务时阻塞线程，让程序按需要顺序执行 判断主线程是否阻塞 防止程序异常崩溃 1. 异步任务时阻塞线程，让程序按需要顺序执行在处理异步任务的时候，通常我们会传入回调来处理请求成功或者失败的逻辑，而我们通过Looper处理消息机制也可以让其顺序执行，不使用回调。我们来看下吧： 1234567891011121314151617181920212223String a = &quot;1&quot;;public void click(View v)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; //模拟耗时操作 SystemClock.sleep(2000); a = &quot;22&quot;; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mHandler.getLooper().quit(); &#125; &#125;); &#125; &#125;).start(); try&#123; Looper.loop(); &#125;catch (Exception e)&#123; &#125; Toast.makeText(getApplicationContext(),a,Toast.LENGTH_LONG).show();&#125; 当点击按钮的时候我们开启线程处理耗时操作，之后调用Looper.loop();方法处理消息循环，也就是说主线程又开始不断的读取queue中的Message并执行。这样当执行mHandler.getLooper().quit();时会调用MessageQueue的quit方法：123456 void quit(boolean safe) &#123; if (!mQuitAllowed) &#123; throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;); &#125; ...&#125; 这个就到了之前我们分析的变量mQuitAllowed,主线程不允许退出，这里会抛出异常，而最终这段代码是在Looper.loop方法中获取消息调用msg.target.dispatchMessage执行的，我们将Looper.loop的异常给捕获住了，从而之后代码继续执行，弹出Toast。 2. 判断主线程是否阻塞一般来说，Loop.loop方法中会不断取出Message，调用其绑定的Handler在UI线程进行执行主线程刷新操作。12345678910if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what);&#125;//注意这里 msg.target为发送msg的Handlermsg.target.dispatchMessage(msg);if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);&#125; 也就是这里，基本上可以说msg.target.dispatchMessage(msg);我们可以根据这行代码的执行时间来判断UI线程是否有耗时操作。 在msg.target.dispatchMessage(msg);前后，分别有logging判断并打印&gt;&gt;&gt;&gt;&gt; Dispatching to和&lt;&lt;&lt;&lt;&lt; Finished to的log，我们可以设置logging并打印相应时间，基本就可以判断消耗时间。 1234567891011121314 Looper.getMainLooper().setMessageLogging(new Printer() &#123; private static final String START = &quot;&gt;&gt;&gt;&gt;&gt; Dispatching&quot;; private static final String END = &quot;&lt;&lt;&lt;&lt;&lt; Finished&quot;; @Override public void println(String x) &#123; if (x.startsWith(START)) &#123; //开始 &#125; if (x.startsWith(END)) &#123; //结束 &#125; &#125;&#125;); 3. 防止程序异常崩溃既然主线程异常事件最终都是在Looper.loop调用中发生的，那我们在Looper.loop方法中将异常捕获住，那主线程的异常也就不会导致程序异常了：123456789101112131415161718192021private Handler mHandler = new Handler(); @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_test); mHandler.post(new Runnable() &#123; @Override public void run() &#123; while (true)&#123; try&#123; Looper.loop(); &#125;catch (Exception e)&#123; &#125; &#125; &#125; &#125;); &#125; public void click2(View v)&#123; int a = 1/0;//除数为0 运行时报错 &#125; 主线程的所有异常都会从我们手动调用的Looper.loop处抛出，一旦抛出就会被try{}catch捕获，这样主线程就不会崩溃了。此原理的开源项目：Cockroach，有兴趣可以看下具体实现。","tags":[{"name":"android","slug":"android","permalink":"https://zhangke3106.github.io/tags/android/"},{"name":"android进阶","slug":"android进阶","permalink":"https://zhangke3106.github.io/tags/android进阶/"}]},{"title":"深入聊聊Android事件分发机制","date":"2017-02-09T15:35:09.000Z","path":"2017/02/09/深入聊聊Android事件分发机制/","text":"在Android开发的过程中，自定义控件一直是我们绕不开的话题。而在这个话题中事件分发机制也是其中的重点和疑点，特别是当我们处理控件嵌套滑动事件时，正确的处理各个控件间事件分发拦截状态，可以实现更炫酷的控件动画效果。 一、事件分发机制介绍关于Android事件分发，我们主要分ViewGroup和View两个事件处理部分进行介绍，主要研究在处理事件过程中关注最多的三个方法dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent，在ViewGroup和View对三个方法的支持如下图所示： 事件种类 ViewGroup View dispatchTouchEvent 有 有 onInterceptTouchEvent 有 无 onTouchEvent 有 有 在Android中，当用户触摸界面时系统会把产生一系列的MotionEvent，通过ViewGroup 的dispatchTouchEvent方法开始向下分发事件，在dispatchTouchEvent方法中，会调用onInterceptTouchEvent方法，如果该方法返回true，表明当前控件拦截了该事件，此后事件交由该控件处理并不再调用该控件的onInterceptTouchEvent方法。最后交由该控件的onTouchEvent方法对事件进行处理。如果当前控件在onInterceptTouchEvent方法中返回false，表示不拦截该控件，之后交由其子控件进行判断是否对事件进行拦截处理。可以用如下伪代码来对其进行处理：123456789public boolean dispatchTouchEvent(MotionEvent event) &#123; boolean consume = false; if (onInterceptTouchEvent(event)) &#123; consume = onTouchEvent(event); &#125; else &#123; consume = child.dispatchTouchEvent(event); &#125; return consume; &#125; 先说结论再细分析： 事件是由其父视图向子视图传递，如图为A-&gt;B-&gt;C 如果当前控件需要拦截该事件，则在onInterceptTouchEvent方法中返回true，但真正决定是否处理事件是在onTouchEvent方法中，也就是说如果此时onTouchEvent方法返回了false，则此控件也表示不处理该事件，交由父控件的onTouchEvent方法来判断处理。如图：当事件由A分发至B，B在其onInterceptTouchEvent方法中返回true表示要拦截该事件，此时事件将不会再传给C，但在B的onTouchEvent方法中返回了false，表示不处理该事件，则事件以此向上传递交由A控件的onTouchEvent方法处理。即onInterceptTouchEvent负责对事件进行拦截，拦截成功后交给最先遇到onTouchEvent返回true的那个view进行处理。 一旦控件确定处理该事件，则后续事件序列也会交由该控件处理，同时该控件的onInterceptTouchEvent方法将不再调用。 由于View没有onInterceptTouchEvent方法，在其dispatchTouchEvent方法中调用onTouchEvent方法处理事件，如果返回false则表示事件不作处理。同时其ACTION_MOVE、ACTION_UP不会得到响应。 View的OnTouchListener优先于onTouchEvent方法执行，如果OnTouchListener方法返回true，那么View的dispatchTouchEvent方法就返回true。而后则onTouchEvent方法得不到执行，同时因为onClick方法在onTouchEvent方法的ACTION_UP中调用，onClick方法也得不到执行。 情况一、A\\B\\C onInterceptTouchEvent onTouchEvent均返回false 事件种类 A(ViewGroup) B(ViewGroup) C(View) onInterceptTouchEvent false false 无 onTouchEvent false false false 当A、B、C同时返回false时，事件传递为A(onInterceptTouchEvent) –&gt;B(onInterceptTouchEvent) –&gt;C(onTouchEvent)–&gt;B(onTouchEvent) –&gt;A(onTouchEvent)，也就是事件从A传至C时，都没有拦截和处理事件，则事件再次向上传递调用B和A的onTouchEvent方法。 看下打印的结果： 情况二、B onInterceptTouchEvent 方法返回true 事件种类 A(ViewGroup) B(ViewGroup) C(View) onInterceptTouchEvent false true 无 onTouchEvent false false false 当BonInterceptTouchEvent返回true时表示拦截了事件，C控件就无法响应该事件。 情况三、B onInterceptTouchEvent 、 onTouchEvent方法返回true 事件种类 A(ViewGroup) B(ViewGroup) C(View) onInterceptTouchEvent false true 无 onTouchEvent false true false 当BonInterceptTouchEvent、onTouchEvent返回true时表示拦截处理了事件，C控件就无法响应该事件，同时事件在B的onTouchEvent之后将不再向上传递，随后事件将不再调用其onInterceptTouchEvent方法。 情况四、C onTouchEvent方法返回true 事件种类 A(ViewGroup) B(ViewGroup) C(View) onInterceptTouchEvent false false 无 onTouchEvent false false true 当ConTouchEvent返回true时表示处理了该事件，之后事件就交由C控件处理，同时事件在C的onTouchEvent之后将不再向上传递。 情况五、A onInterceptTouchEvent方法返回true 事件种类 A(ViewGroup) B(ViewGroup) C(View) onInterceptTouchEvent true false 无 onTouchEvent false false false 当AonInterceptTouchEvent返回true时表示拦截了事件，之后事件就交由A的onTouchEvent方法处理，B、C就无法响应该事件。如果AonTouchEvent方法返回false，其ACTION_MOVE、ACTION_UP事件不会得到响应。 12345678910111213@Override public boolean onTouchEvent(MotionEvent event) &#123; Log.e(TAG, &quot;A --- onTouchEvent&quot;); switch (event.getAction())&#123; case MotionEvent.ACTION_MOVE: Log.e(TAG, &quot;A --- onTouchEvent :ACTION_MOVE&quot;); break; case MotionEvent.ACTION_UP: Log.e(TAG, &quot;A --- onTouchEvent :ACTION_UP&quot;); break; &#125; return false;//super.onTouchEvent(event); &#125; 二、实现侧滑删除效果运用上面的知识学习，我们来实现一下简单的侧滑删除效果吧～ 其核心代码主要在于对事件的拦截和处理上：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123;// boolean intercepter = false; Log.e(&quot;TAG&quot;, &quot;onInterceptTouchEvent: &quot;+ev.getAction()); boolean intercepter = false; if (isMoving) intercepter = true; switch (ev.getAction())&#123; case MotionEvent.ACTION_DOWN: downX = (int) ev.getX(); downY = (int) ev.getY(); if (mVelocityTracker == null) mVelocityTracker = VelocityTracker.obtain(); mVelocityTracker.clear(); break; case MotionEvent.ACTION_MOVE: moveX = (int) ev.getX(); moveY = (int) ev.getY(); Log.e(&quot;TAG&quot;, &quot;getScrollX: &quot;+getScrollX() ); if (Math.abs(moveX - downX) &gt; 0)&#123; intercepter = true; //Log.e(&quot;TAG&quot;,&quot;onInterceptTouchEvent: &quot;); //scrollBy(moveX - downX,0); &#125;else &#123; intercepter = false; &#125; downX = moveX; downY = moveY; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: intercepter = false; break; &#125; //scrollBy(45,0); return intercepter;// //super.onInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; Log.e(&quot;TAG&quot;, &quot;onTouchEvent: &quot;+ev.getAction() ); mVelocityTracker.addMovement(ev); switch (ev.getAction())&#123; case MotionEvent.ACTION_MOVE: moveX = (int) ev.getX(); moveY = (int) ev.getY(); mVelocityTracker.computeCurrentVelocity(1000); Log.e(&quot;TAG&quot;, &quot;getScrollX: &quot;+getScrollX() ); if (getScrollX()+downX - moveX&gt;=0 &amp;&amp; getScrollX()+downX - moveX &lt;= view1.getMeasuredWidth())&#123; scrollBy(downX - moveX,0); &#125; isMoving = true; downX = moveX; downY = moveY; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: Log.e(&quot;TAG1&quot;, &quot;getXVelocity: &quot;+mVelocityTracker.getXVelocity() ); Log.e(&quot;TAG1&quot;, &quot;getYVelocity: &quot;+mVelocityTracker.getYVelocity() ); // if (getScrollX()&gt;=view1.getMeasuredWidth()/2 || mVelocityTracker.getXVelocity() &lt; -ViewConfiguration.get(getContext()).getScaledMinimumFlingVelocity())&#123; //scrollTo(view1.getMeasuredWidth(),0); open(); &#125;else &#123; //scrollTo(0,0); close(); &#125; mVelocityTracker.clear(); mVelocityTracker.recycle(); mVelocityTracker = null; break; &#125; return true;//super.onTouchEvent(ev); &#125; 这里整个父布局继承自ViewGroup，在onMeasure中测量子控件大小：1234567@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); measureChildren(widthMeasureSpec, heightMeasureSpec); setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight()); &#125; 在onFinishInflate方法中获取各个子控件：123456789101112131415161718192021222324@Override protected void onFinishInflate() &#123; super.onFinishInflate(); view = getChildAt(0); view1 = getChildAt(1); if (mScroller == null) mScroller = new Scroller(getContext()); view.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View mViewm, MotionEvent mMotionEventm) &#123; if (mMotionEventm.getAction() == MotionEvent.ACTION_UP &amp;&amp; isOpen)&#123; close(); &#125; if (mMotionEventm.getAction() == MotionEvent.ACTION_DOWN)&#123; if (mOnChangeMenuListener!=null)&#123; mOnChangeMenuListener.onStartTouch(); &#125; &#125; return false; &#125; &#125;); &#125; 并在onLayout方法中布局子控件：12345678910@Override protected void onLayout(boolean mBm, int mIm, int mIm1, int mIm2, int mIm3) &#123; if (getChildCount()!=2)&#123; throw new IllegalArgumentException(&quot;必须包含两个子控件&quot;); &#125; Log.e(&quot;TAG&quot;, &quot;onLayout:getWidth &quot;+view.getWidth() ); view.layout(0,0,view.getMeasuredWidth(),view.getMeasuredHeight()); view1.layout(view.getMeasuredWidth(),0,view.getMeasuredWidth()+view1.getMeasuredWidth(),view1.getMeasuredHeight()); &#125; 重点在对onInterceptTouchEvent和onTouchEvent方法的处理，我们在onInterceptTouchEvent中处理是否拦截该事件。如果手指是向左滑动，则表示用户在进行侧滑删除操作，则拦截该事件，需要注意的是，一旦拦截了该事件，之后事件将不调用该控件的onInterceptTouchEvent方法，所以我们将具体的处理逻辑放在onTouchEvent方法中，该方法返回true表示处理该事件，此后事件都由dispatchTouchEvent方法交由onTouchEvent方法处理。在onTouchEvent方法中调用scrollBy方法实现控件左右滑动，从而实现类似侧滑删除效果。123456789@Override public void computeScroll() &#123; if (mScroller.computeScrollOffset())&#123; scrollTo(mScroller.getCurrX(),mScroller.getCurrY()); invalidate(); &#125;else &#123; isMoving = false; &#125; &#125; 为使滑动效果更自然，用Scroller在手指抬起的时候控制控件打开或者闭合，Scroller的使用也很简单，抬起时调用其startScroll方法并刷新界面，在控件computeScroll方法中判断是否滑动完毕并刷新界面，在invalidate方法中会调用computeScroll从而直到滑动结束。 好了，总的实现就这么多，希望可以加深对事件分发机制的理解～","tags":[{"name":"android","slug":"android","permalink":"https://zhangke3106.github.io/tags/android/"},{"name":"android进阶","slug":"android进阶","permalink":"https://zhangke3106.github.io/tags/android进阶/"},{"name":"android事件分发","slug":"android事件分发","permalink":"https://zhangke3106.github.io/tags/android事件分发/"}]},{"title":"聊聊对Android视图滚动状态的监听","date":"2017-01-21T02:46:20.000Z","path":"2017/01/21/聊聊对Android视图滚动状态的监听/","text":"在官方support.v4包里，提供给我们一个兼容类ViewCompat。ViewCompat里面针对几个版本有不同的实现，根据不同版本进行判断, 但是要注意的是，ViewCompat仅仅让你调用不崩溃，并不保证你调用的结果在不同版本的机器上一致。ViewCompat代码组织的很优雅，有兴趣可以看它的源码。这几天在看代码时注意到ViewCompat的canScrollVertically和canScrollHorizontally方法，官方注释是这样写的： Check if this view can be scrolled vertically in a certain direction. 也就是说，在ViewCompat的canScrollVertically和canScrollHorizontally方法中，我们可以来判断一个控件是否可以继续滚动，这就很有意思了。如果我可以判断出当前视图是否可以继续滚动，可以做出很多有意思的功能，比如下拉刷新或者上拉加载更多等等。 那今天我们就来聊聊这个APIcanScrollVertically，canScrollHorizontally与之同理，希望可以帮助我们在自定义控件中提供新的思路。 我们先看看这个API的具体使用，首先，我在布局文件中放入ScrollView控件，来看看效果： 123456//在MainActivity中 @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.e(TAG, &quot;canScrollVertically: &quot;+ViewCompat.canScrollVertically(mScrollView,-1)); return super.dispatchTouchEvent(ev); &#125; ViewCompat.canScrollVertically的第一个参数表示我们要判断的控件，而第二个参数代表方向，Negative to check scrolling up, positive to check scrolling down.也就是说，负数代表对下滑检测，整数表示对上滑检测，可以看下源码： 1234567891011private boolean canScrollingViewScrollVertically(ScrollingView view, int direction) &#123; final int offset = view.computeVerticalScrollOffset(); final int range = view.computeVerticalScrollRange() - view.computeVerticalScrollExtent(); if (range == 0) return false; if (direction &lt; 0) &#123; return offset &gt; 0; &#125; else &#123; return offset &lt; range - 1; &#125; &#125; 打印如下： 12345678901-20 22:24:59.621 20224-20224/example.view.com.myapplication5 E/MainActivity: canScrollVertically: true01-20 22:24:59.638 20224-20224/example.view.com.myapplication5 E/MainActivity: canScrollVertically: true01-20 22:24:59.654 20224-20224/example.view.com.myapplication5 E/MainActivity: canScrollVertically: true01-20 22:24:59.671 20224-20224/example.view.com.myapplication5 E/MainActivity: canScrollVertically: false01-20 22:24:59.688 20224-20224/example.view.com.myapplication5 E/MainActivity: canScrollVertically: false01-20 22:24:59.704 20224-20224/example.view.com.myapplication5 E/MainActivity: canScrollVertically: false01-20 22:24:59.721 20224-20224/example.view.com.myapplication5 E/MainActivity: canScrollVertically: false01-20 22:24:59.738 20224-20224/example.view.com.myapplication5 E/MainActivity: canScrollVertically: false01-20 22:24:59.754 20224-20224/example.view.com.myapplication5 E/MainActivity: canScrollVertically: false 当手指向下滑到视图最顶端的时候，方法返回false，而当我将ViewCompat.canScrollVertically第二个参数设置为正数1时，在手指上滑到页面最低端时，方法返回false。 这样的话，写个小demo进一步熟悉这个API的使用，感觉以后可以在其他地方更多的用到这个。假设我们控件内部是ScrollView或者ListView或RecyclerView，我们就可以很容易的判断内部控件的滑动状态从而控制外部控件的滑动，比如整个外部控件在ScrollView滑动到顶部时可以下拉滑出界面，我们就可以在滑动过程中用ViewCompat.canScrollVertically来判断是否子控件滑动到顶部或者底部了，从而控制外部控件下滑操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 float mDownMotionY; boolean mChildHasScrolled; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; switch (ev.getActionMasked()) &#123; case MotionEvent.ACTION_DOWN: mDownMotionY = ev.getY(); mChildHasScrolled = false; break; case MotionEvent.ACTION_MOVE: float offsetY = mDownMotionY - ev.getY(); if (!canScrollVertically(view, (int) offsetY,ev))&#123; //说明滚动到底了 Log.e(&quot;TAG&quot;, &quot;dispatchTouchEvent: &quot;+offsetY); if (offsetY &gt; 0)&#123; //说明滚动到底部了// mScrollView.setTranslationY(-offsetY);// return true; &#125;else &#123; //说明滚动到顶部了 view.setTranslationY(-offsetY); return true; &#125; &#125; break; case MotionEvent.ACTION_UP: if (view.getTranslationY() &lt; (getWindow().getDecorView().findViewById(Window.ID_ANDROID_CONTENT).getHeight()/2))&#123; view.animate().translationY(0).setDuration(300).start(); &#125;else &#123; view.animate().translationY(getWindow().getDecorView().getHeight()).setDuration(300).start(); &#125; break; default: break; &#125; return super.dispatchTouchEvent(ev); &#125; ／** * 判断内部子控件是否滑动到顶部/底部 *／ private boolean canScrollVertically(View view, int offSet, MotionEvent ev) &#123; if (!mChildHasScrolled &amp;&amp; !isTransformedTouchPointInView(ev, view)) &#123; return false; &#125; if (ViewCompat.canScrollVertically(view, offSet)) &#123; mChildHasScrolled = true; return true; &#125; if (view instanceof ViewGroup) &#123; ViewGroup vGroup = (ViewGroup) view; for (int i = 0; i &lt; vGroup.getChildCount(); i++) &#123; if (canScrollVertically(vGroup.getChildAt(i), offSet, ev)) &#123; mChildHasScrolled = true; return true; &#125; &#125; &#125; return false; &#125; /*** * 判断MotionEvent是否处于View上面 */ protected boolean isTransformedTouchPointInView(MotionEvent ev, View view) &#123; float x = ev.getRawX(); float y = ev.getRawY(); int[] rect = new int[2]; view.getLocationInWindow(rect); float localX = x - rect[0]; float localY = y - rect[1]; return localX &gt;= 0 &amp;&amp; localX &lt; (view.getRight() - view.getLeft()) &amp;&amp; localY &gt;= 0 &amp;&amp; localY &lt; (view.getBottom() - view.getTop()); &#125; 当然如果发散思维想一下的话，那上拉加载更多我们就完全可以将ScrollView、ListView或RecyclerView放在我们自己定义的控件中，判断其状态显示上拉加载或者下拉显示更多，从而与各个控件处理逻辑完全解耦。当然，我觉得自己还有其他的更有意思的玩法，以后拿来尝试尝试吧～","tags":[{"name":"android","slug":"android","permalink":"https://zhangke3106.github.io/tags/android/"},{"name":"android进阶","slug":"android进阶","permalink":"https://zhangke3106.github.io/tags/android进阶/"}]},{"title":"深入理解Java虚拟机--Java内存区域与内存泄露异常","date":"2017-01-19T14:29:46.000Z","path":"2017/01/19/深入理解Java虚拟机-Java内存区域与内存泄露异常/","text":"最近一直在思考一个问题：作为一个使用Java语言的开发者，面对这么多新框架新特性应该是一种什么姿态呢？当然，努力去学习去了解固然是没错的，但往往会产生一种困惑，为什么要这样写？这样写有什么好处？一般最常见的回答就是这样性能更好，内存占用更低等，但这样的话几乎可以用于回答所有优秀的新框架和新特性，深入分析时由于对底层实现的不了解总是感觉很无力，如果一直处于这种状态，我觉得当我对别人说自己会用多少多少框架的时候，心里总还是有些虚的。作为一个Java语言的使用者，理应对Java有较深的了解，除了语法层面的（比如重写和重载的区别）理解和使用，Java对象是怎么创建的，内存如何分配，对象又是如何查找的、垃圾回收器与内存分配策略、如何对程序调优提高性能等等，在向更高水平进阶的时候，我觉得有必要回过头看看脚下踩着的阶梯是否牢固，为前面的路消除台阶不稳的隐患。研读《深入理解Java虚拟机》一书，这个系列是对书中内容总结理解的读书笔记性质的文章。这就像造物主造出了万物，而我们在找造物主是如何被造出来的一样。希望自己坚持啃完，给以后的自己一个鼓励。 Java内存区域与内存泄露异常 一、运行时数据区域 1、程序计数器1、一块较小的内存空间，当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变计数器的值来选取下一条需要执行的字节码指令。2、线程私有。各线程之间计数器互不影响，独立存储。3、线程当前执行的方法:java方法–计数器记录的是当前正在执行的虚拟机字节码指令的地址。native方法–计数器值为空(Undefined)。4、唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 2、Java虚拟机栈(Java Virtual Machine Stacks)1、线程私有。生命周期与线程相同。描述java方法执行的内存模型。2、 每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。局部变量表：1) 存放编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型)和returnAddress类型(指向一条字节码指令的地址)。2) 内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，方法运行期间不会改变局部变量表的大小。3、每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。4、该区域两种异常状况：1) 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。2) 如果虚拟机栈深度可以动态扩展，扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。 3、本地方法栈(Native Method Stack)1、线程私有。本地方法栈为虚拟机使用到的Native方法服务。2、虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。3、与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 4、Java堆(Java Heap)（线程共享）1、线程共享。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。作用：存放对象实例。2、内存回收。由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。3、内存分配。线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。4、当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 5、方法区（线程共享）1、用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。2、 JDK 1.7的HotSpot中，已经把原本放在永久代（即方法区）的字符串常量池移出。3、这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。4、当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 6、运行时常量池（Runtime Constant Pool）1、是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。除了保存Class文件中描述的符号引用外，还可以把翻译出来的直接引用也存储在运行时常量池中。2、动态性。并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。(如：String类的intern()方法)。3、当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 7、直接内存（并不是虚拟机运行时数据区的一部分）1、在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。避免了在Java堆和Native堆中来回复制数据，从而提高性能。2、本机直接内存的分配不会受到Java堆大小的限制，受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。3、各个内存区域总和大于物理内存限制，导致动态扩展时出现OutOfMemoryError异常。 二、虚拟机对象1、对象的创建 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。 内存分配方式(Java堆是否规整)：1) 指针碰撞。假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。2) 空闲列表。虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。3) Java堆是否规整由所采用的垃圾收集器是否带有压缩整理功能决定 并发情况下也修改指针位置的线程安全问题:1) 问题描述。出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。2) 问题解决。一种是对分配内存空间的动作进行同步处理，实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。3)虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。 2、对象的内存布局 对象头（Header）1) 一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“Mark Word”。 Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。2) 一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 实例数据（Instance Data）对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。从分配策略中可以看出，相同宽度的字段总是被分配到一起。 对齐填充（Padding）1) 并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。2) VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍。当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 3、对象的访问定位 建立对象是为了使用对象，通过栈上的reference数据来操作堆上的具体对象。 句柄Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。 直接指针Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。 使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。 三、OutOfMemoryError异常 Java堆溢出当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的。存在内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。不存在泄露，检查虚拟机的堆参数（-Xmx与-Xms），看是否还可以调大。代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况。 虚拟机栈和本地方法栈溢出假设内存为2GB（操作系统限制）减去Xmx（最大堆容量），再减去MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略掉。如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈“瓜分”了。每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。 方法区和运行时常量池溢出一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。 本机直接内存溢出可通过-XX：MaxDirectMemorySize指定。明显的特征是在Heap Dump文件中不会看见明显的异常。","tags":[{"name":"深入理解java虚拟机","slug":"深入理解java虚拟机","permalink":"https://zhangke3106.github.io/tags/深入理解java虚拟机/"}]},{"title":"实现仿简书选取内容生成分享图片效果","date":"2017-01-19T04:20:09.000Z","path":"2017/01/19/实现仿简书选取内容生成分享图片效果/","text":"前几天脑子里忽然闪过简书的图片分享效果，感觉很简洁也很漂亮，想着能不能用自己方式实现一下呢，于是今天就有了这篇文章。好了，先看下效果图吧： 项目地址: https://github.com/zhangke3016/GeneratePicture 欢迎star、issues~ 实现这个效果，首先要弄明白几个问题： 一、如何获取选取的网页内容二、获取的网页内容如何加载显示 一、如何获取选取的网页内容获取选取的网页内容，通过Java来获取选取的网页内容很困难，而实现效果又必须要得到选取的网页内容，我们可以转换下思路，既然通过Java层不容易得到那通过JavaScript是不是要容易点呢，之后的实现确定这个思路是正确的，JavaScript很容易获取选取的网页内容。 那我们的思路就是：当用户点击生成图片分享按钮后，我们调用JavaScript方法获取选取的网页内容同时回调Java的获取内容方法，将获取的网页内容回传到Java层，我们就可以拿到网页的内容了。简单看下代码：123456789101112131415161718192021222324252627282930313233343536373839404142mWebView.addJavascriptInterface(new WebAppInterface(onGetDataListener), &quot;JSInterface&quot;);public void getSelectedData(WebView webView) &#123; String js = &quot;(function getSelectedText() &#123;&quot; + &quot;var txt;&quot; + &quot;if (window.getSelection) &#123;&quot; + &quot;var range=window.getSelection().getRangeAt(0);&quot; + &quot;var container = window.document.createElement(&apos;div&apos;);&quot; + &quot;container.appendChild(range.cloneContents());&quot; + &quot;txt = container.innerHTML;&quot; + &quot;&#125; else if (window.document.getSelection) &#123;&quot; + &quot;var range=window.getSelection().getRangeAt(0);&quot; + &quot;var container = window.document.createElement(&apos;div&apos;);&quot; + &quot;container.appendChild(range.cloneContents());&quot; + &quot;txt = container.innerHTML;&quot; + &quot;&#125; else if (window.document.selection) &#123;&quot; + &quot;txt = window.document.selection.createRange().htmlText;&quot; + &quot;&#125;&quot; + &quot;JSInterface.getText(txt);&quot; + &quot;&#125;)()&quot;; // calling the js function if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; webView.evaluateJavascript(&quot;javascript:&quot; + js, null); &#125; else &#123; webView.loadUrl(&quot;javascript:&quot; + js); &#125; webView.clearFocus(); &#125; static class WebAppInterface &#123; WebViewHelper.OnGetDataListener onGetDataListener; WebAppInterface(WebViewHelper.OnGetDataListener onGetDataListener) &#123; this.onGetDataListener = onGetDataListener; &#125; @JavascriptInterface public void getText(String text) &#123; onGetDataListener.getDataListener(text); &#125; &#125; public interface OnGetDataListener&#123; void getDataListener(String text); &#125; 上面的实现思路就是当我们要获取选取的网页内容时，给WebView注入一段自己写的JavaScript脚本，这段JavaScript代码的含义就是获取当前页面选取的内容包含html标签，调用JSInterface.getText(txt)方法将内容回传给Java的getText(String text)方法，我们设置onGetDataListener.getDataListener(text)回调方法，由需要的地方调用获取内容。 二、获取的网页内容如何加载显示我们已经获取到了网页内容，按道理其实调用TextView的setText(Html.fromHtml())这个方法就可以显示我们选取的效果，但考虑到美观性以及截图保存功能、图片的正常显示，我选取用WebView来加载获取的网页内容。 这里我是这样处理的：首先在本地assets文件夹下创建一个html页面，在页面里加载基本的显示内容并添加css标签修饰加载的内容，当获取到网页内容时，用JavaScript动态替换本地html页面指定的对应标签内容为获取的网页内容，并在本地html页面里对显示内容进行修饰。 看下代码：1234567891011121314151617181920webView.loadUrl(&quot;file:///android_asset/generate_pic.html&quot;);public void changeDay(String strData,String userInfo,String userName,String other) &#123; if(userInfo == null) userInfo =&quot;&quot;; if(strData == null) strData =&quot;&quot;; if(userName == null) userName =&quot;&quot;; if(other == null) other =&quot;&quot;; strData+=&quot;&lt;br /&gt;&lt;br /&gt;\\n&quot; + &quot;\\t\\t&lt;span style=\\&quot;font-size: small;color: gray;line-height:150%;\\&quot;&gt;&quot;+userInfo+&quot;&lt;/span&gt;\\n&quot; + &quot;\\t\\t&lt;br /&gt;&lt;br /&gt;\\n&quot; + &quot;\\t\\t&lt;hr style=\\&quot;margin: auto;border:0;background-color:gray;height:1px;\\&quot;/&gt;\\n&quot; + &quot;\\t\\t&lt;br /&gt;\\n&quot; + &quot;\\t\\t&lt;p style=\\&quot;color: orangered;font-size: x-small;text-align: center;letter-spacing: 0.5px;\\&quot;&gt;由&lt;strong&gt;&quot;+userName+&quot;&lt;/strong&gt;发送 &quot;+other+&quot;&lt;/p&gt;&quot;; webView.loadUrl(&quot;javascript:changeContent(\\&quot;&quot; + strData.replace(&quot;\\n&quot;, &quot;\\\\n&quot;).replace(&quot;\\&quot;&quot;, &quot;\\\\\\&quot;&quot;).replace(&quot;&apos;&quot;, &quot;\\\\&apos;&quot;) + &quot;\\&quot;)&quot;); webView.setBackgroundColor(Color.WHITE); &#125; 白色和黑色不同的显示效果实现可以在changeDay方法里改变css样式来实现，比较简单。 但这里出现了一个问题：当选取的页面内容有图片且图片是以相对路径显示的时候就加载不到图片了。 在这种情况下图片是相对路径也就是在本地对应的相对路径下找，本地肯定是找不到的，图片也就显示不出来。为了让图片正常显示出来，在选取内容页面调用onLoadResource方法对加载的资源进行判断，将图片路径保存下来，因为既然选取页面图片可以显示处理，说明路径是http路径，可以显示图片。看下代码：1234567891011mWebView.setWebViewClient(new WebViewClient()&#123; @Override public void onLoadResource(WebView view, String url) &#123; //Log.e(&quot;TAG&quot;,&quot;url :&quot;+url); if(url.toLowerCase().contains(&quot;.jpg&quot;) ||url.toLowerCase().contains(&quot;.png&quot;) ||url.toLowerCase().contains(&quot;.gif&quot;))&#123; mlistPath.add(url); &#125; super.onLoadResource(view, url); &#125; 当显示选取内容页面显示时动态修改显示的图片路径，让图片显示出来： 1234567891011121314151617181920webView.setWebViewClient(new WebViewClient()&#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; //view.loadUrl(url); return true; &#125; public WebResourceResponse shouldInterceptRequest(WebView view, String url) &#123; WebResourceResponse response = null; for (String path:WebViewHelper.getInstance().getAllListPath())&#123; if (path.toLowerCase().contains(url.replace(&quot;file://&quot;,&quot;&quot;).toLowerCase()))&#123; try &#123; response = new WebResourceResponse(&quot;image/png&quot;, &quot;UTF-8&quot;, new URL(path).openStream()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return response; &#125; &#125;); 这样，我们的图片就可以显示出来啦！最后，实现我们的截图保存功能，看下代码：123456789101112131415161718192021/** * 截屏 * * @return */ public Bitmap getScreen() &#123; Bitmap bmp = Bitmap.createBitmap(webView.getWidth(), 1, Bitmap.Config.ARGB_8888); int rowBytes = bmp.getRowBytes(); bmp = null; if (rowBytes*webView.getHeight()&gt;=getAvailMemory())&#123; return null; &#125; bmp = Bitmap.createBitmap(webView.getWidth(), webView.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bmp); webView.draw(canvas); return bmp; &#125; private long getAvailMemory() &#123; return Runtime.getRuntime().maxMemory(); &#125; 这里需要对保存的图片大小做下判断，防止创建图片过大OOM。 到这里，基本功能就已经实现了。把图片分享给好友吧~ 项目地址: https://github.com/zhangke3016/GeneratePicture 欢迎star、issues~","tags":[{"name":"android","slug":"android","permalink":"https://zhangke3106.github.io/tags/android/"},{"name":"android进阶","slug":"android进阶","permalink":"https://zhangke3106.github.io/tags/android进阶/"}]},{"title":"两行代码搞定Android视图扩散切换效果","date":"2017-01-19T04:14:09.000Z","path":"2017/01/19/两行代码搞定Android视图扩散切换效果/","text":"用最简单的方式来实现Android视图扩散切换效果。 一、概述这两天时间动手撸了个视图扩散切换效果的控制器，API兼容至Android4.0，更方便我们在视图切换过程中有炫酷的过渡效果。本来是想实现两个View之间的过渡动画，实现的过程中想到之前写的Activity切换动画，就试着加上了对Activity切换的动画支持。先来看看效果吧，代码实现只需一行，感觉还不错～ 二、实现思路简单阐述关于过渡动画的实现，我们先简单分解下这个效果，首先，当Activity发生跳转时我们要先获取共享元素控件，在跳转的界面将其添加在跳转页面之上，关于控件位置的获取，在上一篇文章Android碎裂的粒子效果一文中进行了介绍，主要是通过如下方法获取其位置：12345protected Rect getRectInWindow(View view, boolean mIsFullWindow)&#123; int[] location = new int[2]; view.getLocationInWindow(location); return new Rect(location[0],location[1],location[0]+view.getMeasuredWidth(),location[1]+view.getMeasuredHeight()); &#125; 当跳转至目标页面，我们现在其上方盖上一层遮罩，遮罩为我们自定义的控件，在控件上方绘制上一个页面的过渡视图，将其旋转、平移、或者缩放操作： 123456789canvas.save();Matrix matrix = new Matrix();matrix.postTranslate(mRect.left ,mRect.top);matrix.postScale(mScaleXCanvas,mScaleYCanvas,mRect.centerX(),mRect.centerY());matrix.postRotate(mRotationCanvas,mRect.centerX(),mRect.centerY());canvas.concat(matrix);mView.draw(canvas);canvas.restore(); 最后就是圆形散开效果了，这里我在自定义控件上使用的是Xfermode，不断drawCircle并扩大半径，最终显示出跳转页面视图并将遮罩移除。记得关闭硬件加速。 12mClearPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));setLayerType(LAYER_TYPE_SOFTWARE,null); 返回动画同理，在界面返回前将遮罩盖在上一个页面之上，遮罩包括当前页面的视图影像，不断drawCircle并缩小其半径，同时减小当前页面视图的透明度，最终平滑的显示出上一个页面并移除遮罩。 三、具体使用1234567891011121314151617181920212223242526272829303132333435363738 helper = new BaseViewHelper .Builder(SecondActivity.this) //.setEndView()//如果是两个切换的视图 这里设定最终显示的视图 .setTranslationView(v)//设置过渡视图 .isFullWindow(true)//是否全屏显示 .isShowTransition(true)//是否显示过渡动画 .setDimColor(Color.WHITE)//遮罩颜色 .setDimAlpha(200)//遮罩透明度 //.setTranslationX(0)//x轴平移 //.setRotation(360)//旋转 //.setScaleX(0)//x轴缩放 //.setScaleY(0)//y轴缩放 //.setTranslationY(0)//y轴平移 //.setDuration(800)//过渡时长 //.setInterpolator(new AccelerateDecelerateInterpolator())//设置插值器 //设置监听// .setOnAnimationListener(new BaseViewHelper.OnAnimationListener() &#123;// @Override// public void onAnimationStartIn() &#123;// Log.e(&quot;TAG&quot;,&quot;onAnimationStartIn&quot;);// &#125;//// @Override// public void onAnimationEndIn() &#123;// Log.e(&quot;TAG&quot;,&quot;onAnimationEndIn&quot;);// &#125;//// @Override// public void onAnimationStartOut() &#123;// Log.e(&quot;TAG&quot;,&quot;onAnimationStartOut&quot;);// &#125;//// @Override// public void onAnimationEndOut() &#123;// Log.e(&quot;TAG&quot;,&quot;onAnimationEndOut&quot;);// &#125;// &#125;) .create();//开始动画 如果从A页面跳转至B页面，也就是Activity之间的跳转时，在A页面如下代码 : 123new BaseViewHelper .Builder(MainActivity.this, view) .startActivity(intent); B页面代码： 12345678910111213141516helper = new BaseViewHelper .Builder(SecondActivity.this) .isFullWindow(true)//是否全屏显示 .isShowTransition(true)//是否显示过渡动画 .setDimColor(Color.WHITE)//遮罩颜色 .setDimAlpha(200)//遮罩透明度 .create();//开始动画 @Override public void onBackPressed() &#123; if (helper!=null &amp;&amp; helper.isShowing())&#123; helper.backActivity(this); &#125;else &#123; super.onBackPressed(); &#125; &#125; 如果在一个页面两个视图之间跳转，即A视图切换到B视图：在当前页面代码： 123456789101112131415 View v = View.inflate(this,R.layout.layout_second,null); //显示在当前页面跳转 helper = new BaseViewHelper.Builder(this,view) .setEndView(v) .create();@Overridepublic void onBackPressed() &#123; if (helper!=null &amp;&amp; helper.isShowing())&#123; helper.back(); &#125;else &#123; super.onBackPressed(); &#125;&#125; 四、源码地址 项目地址：https://github.com/zhangke3016/ViewSpreadTranslationController如果喜欢，欢迎star、fork、issues。","tags":[{"name":"android","slug":"android","permalink":"https://zhangke3106.github.io/tags/android/"},{"name":"android进阶","slug":"android进阶","permalink":"https://zhangke3106.github.io/tags/android进阶/"}]},{"title":"更快实现Android多级树形选择列表","date":"2017-01-18T14:59:34.000Z","path":"2017/01/18/更快实现Android多级树形选择列表/","text":"快速实现Android多级树形列表，这个库是在鸿洋多级树形列表demo中修改而来。 解决的问题： 支持ID为int类型和String类型。 支持多级复选框选中，使用只需一行代码。 支持动态更新数据并保持原有展开/关闭状态。 支持ListView、RecyclerView。 项目地址：https://github.com/zhangke3016/MultilevelTreeList 一、概述这几天项目中有一个多级列表的菜单，最开始给我的感觉应该就是嵌套ListView,或者用ExpandableListView，但问题是ExpandableListView只支持两级列表，而且关键的是具体分几级是不确定的，也就是可能一级，可能多级，这要是五六级嵌套ListView，想想那酸爽。。。最终在偷懒心态的驱使下到网上查查看有没有类似的，也确实查到鸿洋大佬之前写的一篇关于实现Android多级树形列表的文章，实现很巧妙，使用一个ListView就可以实现多级列表效果，就download下demo，在demo基础上做了部分修改，功能顺利实现。 其实到这里应该就结束了，但使用过程中遇到的一些问题让我觉得这个可以进一步优化，比如我要做个多级复选列表，每次处理子级选中与父级选中搞得很累，生怕哪个递归错了。而且在新增数据的时候刷新页面也需要自己处理，直接刷新没有效果，再加上现在RecyclerView已经用的越来越多了。就想着在周末好好总结下，封装个方便使用的库，方便下一次有类似需求的时候使用。说到底，还是为了下次可以偷偷懒呗。如果小伙伴有类似需求，也可以直接拿来用~ 先看下效果吧： 这篇文章主要介绍这个库如何使用，如果对具体实现细节感兴趣，可以查看源码或者搜索鸿洋的博客。 二、具体使用我们关联列表树需要有三个必须元素，当前id、父级id即pid，显示的内容。id和pid可以为int或者String以及其他类型。要显示的内容需要包装一下： 12//id pid name FileNode为实际用的实体Bean对象mlist.add(new Node(&quot;223&quot;,&quot;0&quot;,&quot;我也是添加的root节点&quot;,new FileNode())); 对于ListView，需要继承自TreeListViewAdapter,如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class SimpleTreeAdapter extends TreeListViewAdapter&#123; public SimpleTreeAdapter(ListView mTree, Context context, List&lt;Node&gt; datas, int defaultExpandLevel, int iconExpand, int iconNoExpand) &#123; super(mTree, context, datas, defaultExpandLevel, iconExpand, iconNoExpand); &#125; public SimpleTreeAdapter(ListView mTree, Context context, List&lt;Node&gt; datas, int defaultExpandLevel) &#123; super(mTree, context, datas, defaultExpandLevel); &#125; @Override public View getConvertView(final Node node , int position, View convertView, ViewGroup parent) &#123; final ViewHolder viewHolder ; if (convertView == null) &#123; convertView = mInflater.inflate(R.layout.list_item, parent, false); viewHolder = new ViewHolder(); viewHolder.cb = (CheckBox) convertView .findViewById(R.id.cb_select_tree); viewHolder.label = (TextView) convertView .findViewById(R.id.id_treenode_label); viewHolder.icon = (ImageView) convertView.findViewById(R.id.icon); convertView.setTag(viewHolder); &#125; else &#123; viewHolder = (ViewHolder) convertView.getTag(); &#125; viewHolder.cb.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; setChecked(node,viewHolder.cb.isChecked()); &#125; &#125;); if (node.isChecked())&#123; viewHolder.cb.setChecked(true); &#125;else &#123; viewHolder.cb.setChecked(false); &#125; if (node.getIcon() == -1) &#123; viewHolder.icon.setVisibility(View.INVISIBLE); &#125; else &#123; viewHolder.icon.setVisibility(View.VISIBLE); viewHolder.icon.setImageResource(node.getIcon()); &#125; viewHolder.label.setText(node.getName()); return convertView; &#125; private final class ViewHolder &#123; ImageView icon; CheckBox cb; TextView label; &#125;&#125; 对于RecyclerView，需继承自TreeRecyclerAdapter,如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class SimpleTreeRecyclerAdapter extends TreeRecyclerAdapter &#123; public SimpleTreeRecyclerAdapter(RecyclerView mTree, Context context, List&lt;Node&gt; datas, int defaultExpandLevel, int iconExpand, int iconNoExpand) &#123; super(mTree, context, datas, defaultExpandLevel, iconExpand, iconNoExpand); &#125; public SimpleTreeRecyclerAdapter(RecyclerView mTree, Context context, List&lt;Node&gt; datas, int defaultExpandLevel) &#123; super(mTree, context, datas, defaultExpandLevel); &#125; @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; return new MyHoder(View.inflate(mContext, R.layout.list_item,null)); &#125; @Override public void onBindViewHolder(final Node node, RecyclerView.ViewHolder holder, int position) &#123; final MyHoder viewHolder = (MyHoder) holder; //todo do something viewHolder.cb.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; setChecked(node,viewHolder.cb.isChecked()); &#125; &#125;); if (node.isChecked())&#123; viewHolder.cb.setChecked(true); &#125;else &#123; viewHolder.cb.setChecked(false); &#125; if (node.getIcon() == -1) &#123; viewHolder.icon.setVisibility(View.INVISIBLE); &#125; else &#123; viewHolder.icon.setVisibility(View.VISIBLE); viewHolder.icon.setImageResource(node.getIcon()); &#125; viewHolder.label.setText(node.getName()); &#125; class MyHoder extends RecyclerView.ViewHolder&#123; public CheckBox cb; public TextView label; public ImageView icon; public MyHoder(View itemView) &#123; super(itemView); cb = (CheckBox) itemView .findViewById(R.id.cb_select_tree); label = (TextView) itemView .findViewById(R.id.id_treenode_label); icon = (ImageView) itemView.findViewById(R.id.icon); &#125; &#125;&#125; 初始化：ListView:123456789//第一个参数 ListView//第二个参数 上下文//第三个参数 数据集//第四个参数 默认展开层级数 0为不展开//第五个参数 展开的图标//第六个参数 闭合的图标 mAdapter = new SimpleTreeAdapter(mTree, ListViewActivity.this, mDatas, 1,R.mipmap.tree_ex,R.mipmap.tree_ec); mTree.setAdapter(mAdapter); RecyclerView： 12345678910//第一个参数 RecyclerView//第二个参数 上下文//第三个参数 数据集//第四个参数 默认展开层级数 0为不展开//第五个参数 展开的图标//第六个参数 闭合的图标mAdapter = new SimpleTreeRecyclerAdapter(mTree, RecyclerViewActivity.this, mDatas, 1,R.mipmap.tree_ex,R.mipmap.tree_ec);mTree.setAdapter(mAdapter); 添加数据，可以保持原有选中或者展开状态：123List&lt;Node&gt; mlist = new ArrayList&lt;&gt;(); mlist.add(new Node(&quot;223&quot;,&quot;0&quot;,&quot;我也是添加的root节点&quot;,new FileNode())); mAdapter.addData(0,mlist); 获取选中内容：如果node的isChecked()为true，即为选中状态。 123456789101112StringBuilder sb = new StringBuilder(); //获取排序过的nodes //如果不需要刻意直接用 mDatas既可 final List&lt;Node&gt; allNodes = mAdapter.getAllNodes(); for (int i = 0; i &lt; allNodes.size(); i++) &#123; if (allNodes.get(i).isChecked())&#123; sb.append(allNodes.get(i).getName()+&quot;,&quot;); &#125; &#125; String strNodesName = sb.toString(); if (!TextUtils.isEmpty(strNodesName)) Toast.makeText(this, strNodesName.substring(0, strNodesName.length()-1),Toast.LENGTH_SHORT).show(); 控制父子之间联动的选中与取消状态，只需调用setChecked方法既可，注意如果在setOnCheckedChangeListener中处理会有问题：因为如果要子节点/父节点选中或者取消需要刷新页面，而刷新页面又会触发viewHolder.cb.setChecked(true/false);的判断从而又会进入setOnCheckedChangeListener，会导致如果父节点选中某些子节点取消不了的情况。 1234567//viewHolder.cb 为CheckBoxviewHolder.cb.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; setChecked(node,viewHolder.cb.isChecked()); &#125; &#125;); 三、简单介绍通过一个ListView来展示所有数据，每一级内容的显示根据当前展示数据的等级缩进一定的padding值，让我们看起来有缩进效果。 使用过程中感觉不是很舒服的地方在于最终用于显示在界面实体Bean并不是我们传进去的数据，而是经过转化并且过滤的数据，这样最直接的影响就是在我新增数据的数据之后，拿着Adapter来刷新的时候，并没有任何效果。因为我们没有将后面新加的数据进行转化。 而我们如何能在不改变原有数据结构的基础上，添加我们的新内容，并保持原有的选中或者展开正常呢？我的想法是这样的，如果可以直接给它传入转化后的Node节点类型数据就好了，我想到了继承，让实体类去继承基类Node，但一旦继承Node则意味着实体类就不能再继承其他类了，感觉不是很灵活，而且也影响了实体类本身的结构。后来想到了包装设计模式的一些东西，那我就在实体类外再包上一层，也就是将实体类传给Node，最终我们使用的还是Node，但也可以用node.bean很轻松的取出实体类做其他操作，并且实体类本身的结构并没有被破坏。 在此基础上，因为我们的Node不需要转化重新创建，那么它就可以保存一些状态比如展开、选中等等，而在新加入数据时只需标记下新加入的数据，只需对新加入的数据进行初始化状态，已有老数据不进行状态改变: 123if (node.isNewAdd &amp;&amp; defaultExpandLeval &gt;= currentLevel) &#123; node.setExpand(true); &#125; 这样，我们可以保持动态更新添加数据又可以保持原有的展开或选中状态不发生变化，实现我们的需求。 四、源码 项目地址：https://github.com/zhangke3016/MultilevelTreeList","tags":[{"name":"android","slug":"android","permalink":"https://zhangke3106.github.io/tags/android/"}]}]