[{"title":"实现仿简书选取内容生成分享图片效果","date":"2017-01-19T04:20:09.000Z","path":"2017/01/19/实现仿简书选取内容生成分享图片效果/","text":"前几天脑子里忽然闪过简书的图片分享效果，感觉很简洁也很漂亮，想着能不能用自己方式实现一下呢，于是今天就有了这篇文章。好了，先看下效果图吧： 项目地址: https://github.com/zhangke3016/GeneratePicture 欢迎star、issues~ 实现这个效果，首先要弄明白几个问题： 一、如何获取选取的网页内容二、获取的网页内容如何加载显示 一、如何获取选取的网页内容获取选取的网页内容，通过Java来获取选取的网页内容很困难，而实现效果又必须要得到选取的网页内容，我们可以转换下思路，既然通过Java层不容易得到那通过JavaScript是不是要容易点呢，之后的实现确定这个思路是正确的，JavaScript很容易获取选取的网页内容。 那我们的思路就是：当用户点击生成图片分享按钮后，我们调用JavaScript方法获取选取的网页内容同时回调Java的获取内容方法，将获取的网页内容回传到Java层，我们就可以拿到网页的内容了。简单看下代码：123456789101112131415161718192021222324252627282930313233343536373839404142mWebView.addJavascriptInterface(new WebAppInterface(onGetDataListener), &quot;JSInterface&quot;);public void getSelectedData(WebView webView) &#123; String js = &quot;(function getSelectedText() &#123;&quot; + &quot;var txt;&quot; + &quot;if (window.getSelection) &#123;&quot; + &quot;var range=window.getSelection().getRangeAt(0);&quot; + &quot;var container = window.document.createElement(&apos;div&apos;);&quot; + &quot;container.appendChild(range.cloneContents());&quot; + &quot;txt = container.innerHTML;&quot; + &quot;&#125; else if (window.document.getSelection) &#123;&quot; + &quot;var range=window.getSelection().getRangeAt(0);&quot; + &quot;var container = window.document.createElement(&apos;div&apos;);&quot; + &quot;container.appendChild(range.cloneContents());&quot; + &quot;txt = container.innerHTML;&quot; + &quot;&#125; else if (window.document.selection) &#123;&quot; + &quot;txt = window.document.selection.createRange().htmlText;&quot; + &quot;&#125;&quot; + &quot;JSInterface.getText(txt);&quot; + &quot;&#125;)()&quot;; // calling the js function if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; webView.evaluateJavascript(&quot;javascript:&quot; + js, null); &#125; else &#123; webView.loadUrl(&quot;javascript:&quot; + js); &#125; webView.clearFocus(); &#125; static class WebAppInterface &#123; WebViewHelper.OnGetDataListener onGetDataListener; WebAppInterface(WebViewHelper.OnGetDataListener onGetDataListener) &#123; this.onGetDataListener = onGetDataListener; &#125; @JavascriptInterface public void getText(String text) &#123; onGetDataListener.getDataListener(text); &#125; &#125; public interface OnGetDataListener&#123; void getDataListener(String text); &#125; 上面的实现思路就是当我们要获取选取的网页内容时，给WebView注入一段自己写的JavaScript脚本，这段JavaScript代码的含义就是获取当前页面选取的内容包含html标签，调用JSInterface.getText(txt)方法将内容回传给Java的getText(String text)方法，我们设置onGetDataListener.getDataListener(text)回调方法，由需要的地方调用获取内容。 二、获取的网页内容如何加载显示我们已经获取到了网页内容，按道理其实调用TextView的setText(Html.fromHtml())这个方法就可以显示我们选取的效果，但考虑到美观性以及截图保存功能、图片的正常显示，我选取用WebView来加载获取的网页内容。 这里我是这样处理的：首先在本地assets文件夹下创建一个html页面，在页面里加载基本的显示内容并添加css标签修饰加载的内容，当获取到网页内容时，用JavaScript动态替换本地html页面指定的对应标签内容为获取的网页内容，并在本地html页面里对显示内容进行修饰。 看下代码：1234567891011121314151617181920webView.loadUrl(&quot;file:///android_asset/generate_pic.html&quot;);public void changeDay(String strData,String userInfo,String userName,String other) &#123; if(userInfo == null) userInfo =&quot;&quot;; if(strData == null) strData =&quot;&quot;; if(userName == null) userName =&quot;&quot;; if(other == null) other =&quot;&quot;; strData+=&quot;&lt;br /&gt;&lt;br /&gt;\\n&quot; + &quot;\\t\\t&lt;span style=\\&quot;font-size: small;color: gray;line-height:150%;\\&quot;&gt;&quot;+userInfo+&quot;&lt;/span&gt;\\n&quot; + &quot;\\t\\t&lt;br /&gt;&lt;br /&gt;\\n&quot; + &quot;\\t\\t&lt;hr style=\\&quot;margin: auto;border:0;background-color:gray;height:1px;\\&quot;/&gt;\\n&quot; + &quot;\\t\\t&lt;br /&gt;\\n&quot; + &quot;\\t\\t&lt;p style=\\&quot;color: orangered;font-size: x-small;text-align: center;letter-spacing: 0.5px;\\&quot;&gt;由&lt;strong&gt;&quot;+userName+&quot;&lt;/strong&gt;发送 &quot;+other+&quot;&lt;/p&gt;&quot;; webView.loadUrl(&quot;javascript:changeContent(\\&quot;&quot; + strData.replace(&quot;\\n&quot;, &quot;\\\\n&quot;).replace(&quot;\\&quot;&quot;, &quot;\\\\\\&quot;&quot;).replace(&quot;&apos;&quot;, &quot;\\\\&apos;&quot;) + &quot;\\&quot;)&quot;); webView.setBackgroundColor(Color.WHITE); &#125; 白色和黑色不同的显示效果实现可以在changeDay方法里改变css样式来实现，比较简单。 但这里出现了一个问题：当选取的页面内容有图片且图片是以相对路径显示的时候就加载不到图片了。 在这种情况下图片是相对路径也就是在本地对应的相对路径下找，本地肯定是找不到的，图片也就显示不出来。为了让图片正常显示出来，在选取内容页面调用onLoadResource方法对加载的资源进行判断，将图片路径保存下来，因为既然选取页面图片可以显示处理，说明路径是http路径，可以显示图片。看下代码：1234567891011mWebView.setWebViewClient(new WebViewClient()&#123; @Override public void onLoadResource(WebView view, String url) &#123; //Log.e(&quot;TAG&quot;,&quot;url :&quot;+url); if(url.toLowerCase().contains(&quot;.jpg&quot;) ||url.toLowerCase().contains(&quot;.png&quot;) ||url.toLowerCase().contains(&quot;.gif&quot;))&#123; mlistPath.add(url); &#125; super.onLoadResource(view, url); &#125; 当显示选取内容页面显示时动态修改显示的图片路径，让图片显示出来： 1234567891011121314151617181920webView.setWebViewClient(new WebViewClient()&#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; //view.loadUrl(url); return true; &#125; public WebResourceResponse shouldInterceptRequest(WebView view, String url) &#123; WebResourceResponse response = null; for (String path:WebViewHelper.getInstance().getAllListPath())&#123; if (path.toLowerCase().contains(url.replace(&quot;file://&quot;,&quot;&quot;).toLowerCase()))&#123; try &#123; response = new WebResourceResponse(&quot;image/png&quot;, &quot;UTF-8&quot;, new URL(path).openStream()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return response; &#125; &#125;); 这样，我们的图片就可以显示出来啦！最后，实现我们的截图保存功能，看下代码：123456789101112131415161718192021/** * 截屏 * * @return */ public Bitmap getScreen() &#123; Bitmap bmp = Bitmap.createBitmap(webView.getWidth(), 1, Bitmap.Config.ARGB_8888); int rowBytes = bmp.getRowBytes(); bmp = null; if (rowBytes*webView.getHeight()&gt;=getAvailMemory())&#123; return null; &#125; bmp = Bitmap.createBitmap(webView.getWidth(), webView.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bmp); webView.draw(canvas); return bmp; &#125; private long getAvailMemory() &#123; return Runtime.getRuntime().maxMemory(); &#125; 这里需要对保存的图片大小做下判断，防止创建图片过大OOM。 到这里，基本功能就已经实现了。把图片分享给好友吧~ 项目地址: https://github.com/zhangke3016/GeneratePicture 欢迎star、issues~","tags":[{"name":"android","slug":"android","permalink":"https://zhangke3106.github.io/tags/android/"},{"name":"android进阶","slug":"android进阶","permalink":"https://zhangke3106.github.io/tags/android进阶/"}]},{"title":"两行代码搞定Android视图扩散切换效果","date":"2017-01-19T04:14:09.000Z","path":"2017/01/19/两行代码搞定Android视图扩散切换效果/","text":"用最简单的方式来实现Android视图扩散切换效果。 一、概述这两天时间动手撸了个视图扩散切换效果的控制器，API兼容至Android4.0，更方便我们在视图切换过程中有炫酷的过渡效果。本来是想实现两个View之间的过渡动画，实现的过程中想到之前写的Activity切换动画，就试着加上了对Activity切换的动画支持。先来看看效果吧，代码实现只需一行，感觉还不错～ 二、实现思路简单阐述关于过渡动画的实现，我们先简单分解下这个效果，首先，当Activity发生跳转时我们要先获取共享元素控件，在跳转的界面将其添加在跳转页面之上，关于控件位置的获取，在上一篇文章Android碎裂的粒子效果一文中进行了介绍，主要是通过如下方法获取其位置：12345protected Rect getRectInWindow(View view, boolean mIsFullWindow)&#123; int[] location = new int[2]; view.getLocationInWindow(location); return new Rect(location[0],location[1],location[0]+view.getMeasuredWidth(),location[1]+view.getMeasuredHeight()); &#125; 当跳转至目标页面，我们现在其上方盖上一层遮罩，遮罩为我们自定义的控件，在控件上方绘制上一个页面的过渡视图，将其旋转、平移、或者缩放操作： 123456789canvas.save();Matrix matrix = new Matrix();matrix.postTranslate(mRect.left ,mRect.top);matrix.postScale(mScaleXCanvas,mScaleYCanvas,mRect.centerX(),mRect.centerY());matrix.postRotate(mRotationCanvas,mRect.centerX(),mRect.centerY());canvas.concat(matrix);mView.draw(canvas);canvas.restore(); 最后就是圆形散开效果了，这里我在自定义控件上使用的是Xfermode，不断drawCircle并扩大半径，最终显示出跳转页面视图并将遮罩移除。记得关闭硬件加速。 12mClearPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));setLayerType(LAYER_TYPE_SOFTWARE,null); 返回动画同理，在界面返回前将遮罩盖在上一个页面之上，遮罩包括当前页面的视图影像，不断drawCircle并缩小其半径，同时减小当前页面视图的透明度，最终平滑的显示出上一个页面并移除遮罩。 三、具体使用1234567891011121314151617181920212223242526272829303132333435363738 helper = new BaseViewHelper .Builder(SecondActivity.this) //.setEndView()//如果是两个切换的视图 这里设定最终显示的视图 .setTranslationView(v)//设置过渡视图 .isFullWindow(true)//是否全屏显示 .isShowTransition(true)//是否显示过渡动画 .setDimColor(Color.WHITE)//遮罩颜色 .setDimAlpha(200)//遮罩透明度 //.setTranslationX(0)//x轴平移 //.setRotation(360)//旋转 //.setScaleX(0)//x轴缩放 //.setScaleY(0)//y轴缩放 //.setTranslationY(0)//y轴平移 //.setDuration(800)//过渡时长 //.setInterpolator(new AccelerateDecelerateInterpolator())//设置插值器 //设置监听// .setOnAnimationListener(new BaseViewHelper.OnAnimationListener() &#123;// @Override// public void onAnimationStartIn() &#123;// Log.e(&quot;TAG&quot;,&quot;onAnimationStartIn&quot;);// &#125;//// @Override// public void onAnimationEndIn() &#123;// Log.e(&quot;TAG&quot;,&quot;onAnimationEndIn&quot;);// &#125;//// @Override// public void onAnimationStartOut() &#123;// Log.e(&quot;TAG&quot;,&quot;onAnimationStartOut&quot;);// &#125;//// @Override// public void onAnimationEndOut() &#123;// Log.e(&quot;TAG&quot;,&quot;onAnimationEndOut&quot;);// &#125;// &#125;) .create();//开始动画 如果从A页面跳转至B页面，也就是Activity之间的跳转时，在A页面如下代码 : 123new BaseViewHelper .Builder(MainActivity.this, view) .startActivity(intent); B页面代码： 12345678910111213141516helper = new BaseViewHelper .Builder(SecondActivity.this) .isFullWindow(true)//是否全屏显示 .isShowTransition(true)//是否显示过渡动画 .setDimColor(Color.WHITE)//遮罩颜色 .setDimAlpha(200)//遮罩透明度 .create();//开始动画 @Override public void onBackPressed() &#123; if (helper!=null &amp;&amp; helper.isShowing())&#123; helper.backActivity(this); &#125;else &#123; super.onBackPressed(); &#125; &#125; 如果在一个页面两个视图之间跳转，即A视图切换到B视图：在当前页面代码： 123456789101112131415 View v = View.inflate(this,R.layout.layout_second,null); //显示在当前页面跳转 helper = new BaseViewHelper.Builder(this,view) .setEndView(v) .create();@Overridepublic void onBackPressed() &#123; if (helper!=null &amp;&amp; helper.isShowing())&#123; helper.back(); &#125;else &#123; super.onBackPressed(); &#125;&#125; 四、源码地址 项目地址：https://github.com/zhangke3016/ViewSpreadTranslationController如果喜欢，欢迎star、fork、issues。","tags":[{"name":"android","slug":"android","permalink":"https://zhangke3106.github.io/tags/android/"},{"name":"android进阶","slug":"android进阶","permalink":"https://zhangke3106.github.io/tags/android进阶/"}]},{"title":"更快实现Android多级树形选择列表","date":"2017-01-18T14:59:34.000Z","path":"2017/01/18/更快实现Android多级树形选择列表/","text":"快速实现Android多级树形列表，这个库是在鸿洋多级树形列表demo中修改而来。 解决的问题： 支持ID为int类型和String类型。 支持多级复选框选中，使用只需一行代码。 支持动态更新数据并保持原有展开/关闭状态。 支持ListView、RecyclerView。 项目地址：https://github.com/zhangke3016/MultilevelTreeList 一、概述这几天项目中有一个多级列表的菜单，最开始给我的感觉应该就是嵌套ListView,或者用ExpandableListView，但问题是ExpandableListView只支持两级列表，而且关键的是具体分几级是不确定的，也就是可能一级，可能多级，这要是五六级嵌套ListView，想想那酸爽。。。最终在偷懒心态的驱使下到网上查查看有没有类似的，也确实查到鸿洋大佬之前写的一篇关于实现Android多级树形列表的文章，实现很巧妙，使用一个ListView就可以实现多级列表效果，就download下demo，在demo基础上做了部分修改，功能顺利实现。 其实到这里应该就结束了，但使用过程中遇到的一些问题让我觉得这个可以进一步优化，比如我要做个多级复选列表，每次处理子级选中与父级选中搞得很累，生怕哪个递归错了。而且在新增数据的时候刷新页面也需要自己处理，直接刷新没有效果，再加上现在RecyclerView已经用的越来越多了。就想着在周末好好总结下，封装个方便使用的库，方便下一次有类似需求的时候使用。说到底，还是为了下次可以偷偷懒呗。如果小伙伴有类似需求，也可以直接拿来用~ 先看下效果吧： 这篇文章主要介绍这个库如何使用，如果对具体实现细节感兴趣，可以查看源码或者搜索鸿洋的博客。 二、具体使用我们关联列表树需要有三个必须元素，当前id、父级id即pid，显示的内容。id和pid可以为int或者String以及其他类型。要显示的内容需要包装一下： 12//id pid name FileNode为实际用的实体Bean对象mlist.add(new Node(&quot;223&quot;,&quot;0&quot;,&quot;我也是添加的root节点&quot;,new FileNode())); 对于ListView，需要继承自TreeListViewAdapter,如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class SimpleTreeAdapter extends TreeListViewAdapter&#123; public SimpleTreeAdapter(ListView mTree, Context context, List&lt;Node&gt; datas, int defaultExpandLevel, int iconExpand, int iconNoExpand) &#123; super(mTree, context, datas, defaultExpandLevel, iconExpand, iconNoExpand); &#125; public SimpleTreeAdapter(ListView mTree, Context context, List&lt;Node&gt; datas, int defaultExpandLevel) &#123; super(mTree, context, datas, defaultExpandLevel); &#125; @Override public View getConvertView(final Node node , int position, View convertView, ViewGroup parent) &#123; final ViewHolder viewHolder ; if (convertView == null) &#123; convertView = mInflater.inflate(R.layout.list_item, parent, false); viewHolder = new ViewHolder(); viewHolder.cb = (CheckBox) convertView .findViewById(R.id.cb_select_tree); viewHolder.label = (TextView) convertView .findViewById(R.id.id_treenode_label); viewHolder.icon = (ImageView) convertView.findViewById(R.id.icon); convertView.setTag(viewHolder); &#125; else &#123; viewHolder = (ViewHolder) convertView.getTag(); &#125; viewHolder.cb.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; setChecked(node,viewHolder.cb.isChecked()); &#125; &#125;); if (node.isChecked())&#123; viewHolder.cb.setChecked(true); &#125;else &#123; viewHolder.cb.setChecked(false); &#125; if (node.getIcon() == -1) &#123; viewHolder.icon.setVisibility(View.INVISIBLE); &#125; else &#123; viewHolder.icon.setVisibility(View.VISIBLE); viewHolder.icon.setImageResource(node.getIcon()); &#125; viewHolder.label.setText(node.getName()); return convertView; &#125; private final class ViewHolder &#123; ImageView icon; CheckBox cb; TextView label; &#125;&#125; 对于RecyclerView，需继承自TreeRecyclerAdapter,如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class SimpleTreeRecyclerAdapter extends TreeRecyclerAdapter &#123; public SimpleTreeRecyclerAdapter(RecyclerView mTree, Context context, List&lt;Node&gt; datas, int defaultExpandLevel, int iconExpand, int iconNoExpand) &#123; super(mTree, context, datas, defaultExpandLevel, iconExpand, iconNoExpand); &#125; public SimpleTreeRecyclerAdapter(RecyclerView mTree, Context context, List&lt;Node&gt; datas, int defaultExpandLevel) &#123; super(mTree, context, datas, defaultExpandLevel); &#125; @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; return new MyHoder(View.inflate(mContext, R.layout.list_item,null)); &#125; @Override public void onBindViewHolder(final Node node, RecyclerView.ViewHolder holder, int position) &#123; final MyHoder viewHolder = (MyHoder) holder; //todo do something viewHolder.cb.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; setChecked(node,viewHolder.cb.isChecked()); &#125; &#125;); if (node.isChecked())&#123; viewHolder.cb.setChecked(true); &#125;else &#123; viewHolder.cb.setChecked(false); &#125; if (node.getIcon() == -1) &#123; viewHolder.icon.setVisibility(View.INVISIBLE); &#125; else &#123; viewHolder.icon.setVisibility(View.VISIBLE); viewHolder.icon.setImageResource(node.getIcon()); &#125; viewHolder.label.setText(node.getName()); &#125; class MyHoder extends RecyclerView.ViewHolder&#123; public CheckBox cb; public TextView label; public ImageView icon; public MyHoder(View itemView) &#123; super(itemView); cb = (CheckBox) itemView .findViewById(R.id.cb_select_tree); label = (TextView) itemView .findViewById(R.id.id_treenode_label); icon = (ImageView) itemView.findViewById(R.id.icon); &#125; &#125;&#125; 初始化：ListView:123456789//第一个参数 ListView//第二个参数 上下文//第三个参数 数据集//第四个参数 默认展开层级数 0为不展开//第五个参数 展开的图标//第六个参数 闭合的图标 mAdapter = new SimpleTreeAdapter(mTree, ListViewActivity.this, mDatas, 1,R.mipmap.tree_ex,R.mipmap.tree_ec); mTree.setAdapter(mAdapter); RecyclerView： 12345678910//第一个参数 RecyclerView//第二个参数 上下文//第三个参数 数据集//第四个参数 默认展开层级数 0为不展开//第五个参数 展开的图标//第六个参数 闭合的图标mAdapter = new SimpleTreeRecyclerAdapter(mTree, RecyclerViewActivity.this, mDatas, 1,R.mipmap.tree_ex,R.mipmap.tree_ec);mTree.setAdapter(mAdapter); 添加数据，可以保持原有选中或者展开状态：123List&lt;Node&gt; mlist = new ArrayList&lt;&gt;(); mlist.add(new Node(&quot;223&quot;,&quot;0&quot;,&quot;我也是添加的root节点&quot;,new FileNode())); mAdapter.addData(0,mlist); 获取选中内容：如果node的isChecked()为true，即为选中状态。 123456789101112StringBuilder sb = new StringBuilder(); //获取排序过的nodes //如果不需要刻意直接用 mDatas既可 final List&lt;Node&gt; allNodes = mAdapter.getAllNodes(); for (int i = 0; i &lt; allNodes.size(); i++) &#123; if (allNodes.get(i).isChecked())&#123; sb.append(allNodes.get(i).getName()+&quot;,&quot;); &#125; &#125; String strNodesName = sb.toString(); if (!TextUtils.isEmpty(strNodesName)) Toast.makeText(this, strNodesName.substring(0, strNodesName.length()-1),Toast.LENGTH_SHORT).show(); 控制父子之间联动的选中与取消状态，只需调用setChecked方法既可，注意如果在setOnCheckedChangeListener中处理会有问题：因为如果要子节点/父节点选中或者取消需要刷新页面，而刷新页面又会触发viewHolder.cb.setChecked(true/false);的判断从而又会进入setOnCheckedChangeListener，会导致如果父节点选中某些子节点取消不了的情况。 1234567//viewHolder.cb 为CheckBoxviewHolder.cb.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; setChecked(node,viewHolder.cb.isChecked()); &#125; &#125;); 三、简单介绍通过一个ListView来展示所有数据，每一级内容的显示根据当前展示数据的等级缩进一定的padding值，让我们看起来有缩进效果。 使用过程中感觉不是很舒服的地方在于最终用于显示在界面实体Bean并不是我们传进去的数据，而是经过转化并且过滤的数据，这样最直接的影响就是在我新增数据的数据之后，拿着Adapter来刷新的时候，并没有任何效果。因为我们没有将后面新加的数据进行转化。 而我们如何能在不改变原有数据结构的基础上，添加我们的新内容，并保持原有的选中或者展开正常呢？我的想法是这样的，如果可以直接给它传入转化后的Node节点类型数据就好了，我想到了继承，让实体类去继承基类Node，但一旦继承Node则意味着实体类就不能再继承其他类了，感觉不是很灵活，而且也影响了实体类本身的结构。后来想到了包装设计模式的一些东西，那我就在实体类外再包上一层，也就是将实体类传给Node，最终我们使用的还是Node，但也可以用node.bean很轻松的取出实体类做其他操作，并且实体类本身的结构并没有被破坏。 在此基础上，因为我们的Node不需要转化重新创建，那么它就可以保存一些状态比如展开、选中等等，而在新加入数据时只需标记下新加入的数据，只需对新加入的数据进行初始化状态，已有老数据不进行状态改变: 123if (node.isNewAdd &amp;&amp; defaultExpandLeval &gt;= currentLevel) &#123; node.setExpand(true); &#125; 这样，我们可以保持动态更新添加数据又可以保持原有的展开或选中状态不发生变化，实现我们的需求。 四、源码 项目地址：https://github.com/zhangke3016/MultilevelTreeList","tags":[{"name":"android","slug":"android","permalink":"https://zhangke3106.github.io/tags/android/"}]},{"title":"Hello World","date":"2017-01-18T09:11:33.000Z","path":"2017/01/18/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]