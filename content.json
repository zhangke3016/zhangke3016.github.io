[{"title":"聊聊对Android视图滚动状态的监听","date":"2017-01-21T02:46:20.000Z","path":"2017/01/21/聊聊对Android视图滚动状态的监听/","text":"在官方support.v4包里，提供给我们一个兼容类ViewCompat。ViewCompat里面针对几个版本有不同的实现，根据不同版本进行判断, 但是要注意的是，ViewCompat仅仅让你调用不崩溃，并不保证你调用的结果在不同版本的机器上一致。ViewCompat代码组织的很优雅，有兴趣可以看它的源码。这几天在看代码时注意到ViewCompat的canScrollVertically和canScrollHorizontally方法，官方注释是这样写的： Check if this view can be scrolled vertically in a certain direction. 也就是说，在ViewCompat的canScrollVertically和canScrollHorizontally方法中，我们可以来判断一个控件是否可以继续滚动，这就很有意思了。如果我可以判断出当前视图是否可以继续滚动，可以做出很多有意思的功能，比如下拉刷新或者上拉加载更多等等。 那今天我们就来聊聊这个APIcanScrollVertically，canScrollHorizontally与之同理，希望可以帮助我们在自定义控件中提供新的思路。 我们先看看这个API的具体使用，首先，我在布局文件中放入ScrollView控件，来看看效果： 123456//在MainActivity中 @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.e(TAG, &quot;canScrollVertically: &quot;+ViewCompat.canScrollVertically(mScrollView,-1)); return super.dispatchTouchEvent(ev); &#125; ViewCompat.canScrollVertically的第一个参数表示我们要判断的控件，而第二个参数代表方向，Negative to check scrolling up, positive to check scrolling down.也就是说，负数代表对下滑检测，整数表示对上滑检测，可以看下源码： 1234567891011private boolean canScrollingViewScrollVertically(ScrollingView view, int direction) &#123; final int offset = view.computeVerticalScrollOffset(); final int range = view.computeVerticalScrollRange() - view.computeVerticalScrollExtent(); if (range == 0) return false; if (direction &lt; 0) &#123; return offset &gt; 0; &#125; else &#123; return offset &lt; range - 1; &#125; &#125; 打印如下： 12345678901-20 22:24:59.621 20224-20224/example.view.com.myapplication5 E/MainActivity: canScrollVertically: true01-20 22:24:59.638 20224-20224/example.view.com.myapplication5 E/MainActivity: canScrollVertically: true01-20 22:24:59.654 20224-20224/example.view.com.myapplication5 E/MainActivity: canScrollVertically: true01-20 22:24:59.671 20224-20224/example.view.com.myapplication5 E/MainActivity: canScrollVertically: false01-20 22:24:59.688 20224-20224/example.view.com.myapplication5 E/MainActivity: canScrollVertically: false01-20 22:24:59.704 20224-20224/example.view.com.myapplication5 E/MainActivity: canScrollVertically: false01-20 22:24:59.721 20224-20224/example.view.com.myapplication5 E/MainActivity: canScrollVertically: false01-20 22:24:59.738 20224-20224/example.view.com.myapplication5 E/MainActivity: canScrollVertically: false01-20 22:24:59.754 20224-20224/example.view.com.myapplication5 E/MainActivity: canScrollVertically: false 当手指向下滑到视图最顶端的时候，方法返回false，而当我将ViewCompat.canScrollVertically第二个参数设置为正数1时，在手指上滑到页面最低端时，方法返回false。 这样的话，写个小demo进一步熟悉这个API的使用，感觉以后可以在其他地方更多的用到这个。假设我们控件内部是ScrollView或者ListView或RecyclerView，我们就可以很容易的判断内部控件的滑动状态从而控制外部控件的滑动，比如整个外部控件在ScrollView滑动到顶部时可以下拉滑出界面，我们就可以在滑动过程中用ViewCompat.canScrollVertically来判断是否子控件滑动到顶部或者底部了，从而控制外部控件下滑操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 float mDownMotionY; boolean mChildHasScrolled; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; switch (ev.getActionMasked()) &#123; case MotionEvent.ACTION_DOWN: mDownMotionY = ev.getY(); mChildHasScrolled = false; break; case MotionEvent.ACTION_MOVE: float offsetY = mDownMotionY - ev.getY(); if (!canScrollVertically(view, (int) offsetY,ev))&#123; //说明滚动到底了 Log.e(&quot;TAG&quot;, &quot;dispatchTouchEvent: &quot;+offsetY); if (offsetY &gt; 0)&#123; //说明滚动到底部了// mScrollView.setTranslationY(-offsetY);// return true; &#125;else &#123; //说明滚动到顶部了 view.setTranslationY(-offsetY); return true; &#125; &#125; break; case MotionEvent.ACTION_UP: if (view.getTranslationY() &lt; (getWindow().getDecorView().findViewById(Window.ID_ANDROID_CONTENT).getHeight()/2))&#123; view.animate().translationY(0).setDuration(300).start(); &#125;else &#123; view.animate().translationY(getWindow().getDecorView().getHeight()).setDuration(300).start(); &#125; break; default: break; &#125; return super.dispatchTouchEvent(ev); &#125; ／** * 判断内部子控件是否滑动到顶部/底部 *／ private boolean canScrollVertically(View view, int offSet, MotionEvent ev) &#123; if (!mChildHasScrolled &amp;&amp; !isTransformedTouchPointInView(ev, view)) &#123; return false; &#125; if (ViewCompat.canScrollVertically(view, offSet)) &#123; mChildHasScrolled = true; return true; &#125; if (view instanceof ViewGroup) &#123; ViewGroup vGroup = (ViewGroup) view; for (int i = 0; i &lt; vGroup.getChildCount(); i++) &#123; if (canScrollVertically(vGroup.getChildAt(i), offSet, ev)) &#123; mChildHasScrolled = true; return true; &#125; &#125; &#125; return false; &#125; /*** * 判断MotionEvent是否处于View上面 */ protected boolean isTransformedTouchPointInView(MotionEvent ev, View view) &#123; float x = ev.getRawX(); float y = ev.getRawY(); int[] rect = new int[2]; view.getLocationInWindow(rect); float localX = x - rect[0]; float localY = y - rect[1]; return localX &gt;= 0 &amp;&amp; localX &lt; (view.getRight() - view.getLeft()) &amp;&amp; localY &gt;= 0 &amp;&amp; localY &lt; (view.getBottom() - view.getTop()); &#125; 当然如果发散思维想一下的话，那上拉加载更多我们就完全可以将ScrollView、ListView或RecyclerView放在我们自己定义的控件中，判断其状态显示上拉加载或者下拉显示更多，从而与各个控件处理逻辑完全解耦。当然，我觉得自己还有其他的更有意思的玩法，以后拿来尝试尝试吧～","tags":[{"name":"android","slug":"android","permalink":"https://zhangke3106.github.io/tags/android/"},{"name":"android进阶","slug":"android进阶","permalink":"https://zhangke3106.github.io/tags/android进阶/"}]},{"title":"深入理解Java虚拟机--Java内存区域与内存泄露异常","date":"2017-01-19T14:29:46.000Z","path":"2017/01/19/深入理解Java虚拟机-Java内存区域与内存泄露异常/","text":"最近一直在思考一个问题：作为一个使用Java语言的开发者，面对这么多新框架新特性应该是一种什么姿态呢？当然，努力去学习去了解固然是没错的，但往往会产生一种困惑，为什么要这样写？这样写有什么好处？一般最常见的回答就是这样性能更好，内存占用更低等，但这样的话几乎可以用于回答所有优秀的新框架和新特性，深入分析时由于对底层实现的不了解总是感觉很无力，如果一直处于这种状态，我觉得当我对别人说自己会用多少多少框架的时候，心里总还是有些虚的。作为一个Java语言的使用者，理应对Java有较深的了解，除了语法层面的（比如重写和重载的区别）理解和使用，Java对象是怎么创建的，内存如何分配，对象又是如何查找的、垃圾回收器与内存分配策略、如何对程序调优提高性能等等，在向更高水平进阶的时候，我觉得有必要回过头看看脚下踩着的阶梯是否牢固，为前面的路消除台阶不稳的隐患。研读《深入理解Java虚拟机》一书，这个系列是对书中内容总结理解的读书笔记性质的文章。这就像造物主造出了万物，而我们在找造物主是如何被造出来的一样。希望自己坚持啃完，给以后的自己一个鼓励。 Java内存区域与内存泄露异常 一、运行时数据区域 1、程序计数器1、一块较小的内存空间，当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变计数器的值来选取下一条需要执行的字节码指令。2、线程私有。各线程之间计数器互不影响，独立存储。3、线程当前执行的方法:java方法–计数器记录的是当前正在执行的虚拟机字节码指令的地址。native方法–计数器值为空(Undefined)。4、唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 2、Java虚拟机栈(Java Virtual Machine Stacks)1、线程私有。生命周期与线程相同。描述java方法执行的内存模型。2、 每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。局部变量表：1) 存放编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型)和returnAddress类型(指向一条字节码指令的地址)。2) 内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，方法运行期间不会改变局部变量表的大小。3、每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。4、该区域两种异常状况：1) 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。2) 如果虚拟机栈深度可以动态扩展，扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。 3、本地方法栈(Native Method Stack)1、线程私有。本地方法栈为虚拟机使用到的Native方法服务。2、虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。3、与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 4、Java堆(Java Heap)（线程共享）1、线程共享。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。作用：存放对象实例。2、内存回收。由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。3、内存分配。线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。4、当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 5、方法区（线程共享）1、用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。2、 JDK 1.7的HotSpot中，已经把原本放在永久代（即方法区）的字符串常量池移出。3、这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。4、当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 6、运行时常量池（Runtime Constant Pool）1、是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。除了保存Class文件中描述的符号引用外，还可以把翻译出来的直接引用也存储在运行时常量池中。2、动态性。并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。(如：String类的intern()方法)。3、当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 7、直接内存（并不是虚拟机运行时数据区的一部分）1、在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。避免了在Java堆和Native堆中来回复制数据，从而提高性能。2、本机直接内存的分配不会受到Java堆大小的限制，受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。3、各个内存区域总和大于物理内存限制，导致动态扩展时出现OutOfMemoryError异常。 二、虚拟机对象1、对象的创建 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。 内存分配方式(Java堆是否规整)：1) 指针碰撞。假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。2) 空闲列表。虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。3) Java堆是否规整由所采用的垃圾收集器是否带有压缩整理功能决定 并发情况下也修改指针位置的线程安全问题:1) 问题描述。出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。2) 问题解决。一种是对分配内存空间的动作进行同步处理，实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。3)虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。 2、对象的内存布局 对象头（Header）1) 一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“Mark Word”。 Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。2) 一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 实例数据（Instance Data）对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。从分配策略中可以看出，相同宽度的字段总是被分配到一起。 对齐填充（Padding）1) 并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。2) VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍。当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 3、对象的访问定位 建立对象是为了使用对象，通过栈上的reference数据来操作堆上的具体对象。 句柄Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。 直接指针Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。 使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。 三、OutOfMemoryError异常 Java堆溢出当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的。存在内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。不存在泄露，检查虚拟机的堆参数（-Xmx与-Xms），看是否还可以调大。代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况。 虚拟机栈和本地方法栈溢出假设内存为2GB（操作系统限制）减去Xmx（最大堆容量），再减去MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略掉。如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈“瓜分”了。每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。 方法区和运行时常量池溢出一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。 本机直接内存溢出可通过-XX：MaxDirectMemorySize指定。明显的特征是在Heap Dump文件中不会看见明显的异常。","tags":[{"name":"深入理解java虚拟机","slug":"深入理解java虚拟机","permalink":"https://zhangke3106.github.io/tags/深入理解java虚拟机/"}]},{"title":"实现仿简书选取内容生成分享图片效果","date":"2017-01-19T04:20:09.000Z","path":"2017/01/19/实现仿简书选取内容生成分享图片效果/","text":"前几天脑子里忽然闪过简书的图片分享效果，感觉很简洁也很漂亮，想着能不能用自己方式实现一下呢，于是今天就有了这篇文章。好了，先看下效果图吧： 项目地址: https://github.com/zhangke3016/GeneratePicture 欢迎star、issues~ 实现这个效果，首先要弄明白几个问题： 一、如何获取选取的网页内容二、获取的网页内容如何加载显示 一、如何获取选取的网页内容获取选取的网页内容，通过Java来获取选取的网页内容很困难，而实现效果又必须要得到选取的网页内容，我们可以转换下思路，既然通过Java层不容易得到那通过JavaScript是不是要容易点呢，之后的实现确定这个思路是正确的，JavaScript很容易获取选取的网页内容。 那我们的思路就是：当用户点击生成图片分享按钮后，我们调用JavaScript方法获取选取的网页内容同时回调Java的获取内容方法，将获取的网页内容回传到Java层，我们就可以拿到网页的内容了。简单看下代码：123456789101112131415161718192021222324252627282930313233343536373839404142mWebView.addJavascriptInterface(new WebAppInterface(onGetDataListener), &quot;JSInterface&quot;);public void getSelectedData(WebView webView) &#123; String js = &quot;(function getSelectedText() &#123;&quot; + &quot;var txt;&quot; + &quot;if (window.getSelection) &#123;&quot; + &quot;var range=window.getSelection().getRangeAt(0);&quot; + &quot;var container = window.document.createElement(&apos;div&apos;);&quot; + &quot;container.appendChild(range.cloneContents());&quot; + &quot;txt = container.innerHTML;&quot; + &quot;&#125; else if (window.document.getSelection) &#123;&quot; + &quot;var range=window.getSelection().getRangeAt(0);&quot; + &quot;var container = window.document.createElement(&apos;div&apos;);&quot; + &quot;container.appendChild(range.cloneContents());&quot; + &quot;txt = container.innerHTML;&quot; + &quot;&#125; else if (window.document.selection) &#123;&quot; + &quot;txt = window.document.selection.createRange().htmlText;&quot; + &quot;&#125;&quot; + &quot;JSInterface.getText(txt);&quot; + &quot;&#125;)()&quot;; // calling the js function if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; webView.evaluateJavascript(&quot;javascript:&quot; + js, null); &#125; else &#123; webView.loadUrl(&quot;javascript:&quot; + js); &#125; webView.clearFocus(); &#125; static class WebAppInterface &#123; WebViewHelper.OnGetDataListener onGetDataListener; WebAppInterface(WebViewHelper.OnGetDataListener onGetDataListener) &#123; this.onGetDataListener = onGetDataListener; &#125; @JavascriptInterface public void getText(String text) &#123; onGetDataListener.getDataListener(text); &#125; &#125; public interface OnGetDataListener&#123; void getDataListener(String text); &#125; 上面的实现思路就是当我们要获取选取的网页内容时，给WebView注入一段自己写的JavaScript脚本，这段JavaScript代码的含义就是获取当前页面选取的内容包含html标签，调用JSInterface.getText(txt)方法将内容回传给Java的getText(String text)方法，我们设置onGetDataListener.getDataListener(text)回调方法，由需要的地方调用获取内容。 二、获取的网页内容如何加载显示我们已经获取到了网页内容，按道理其实调用TextView的setText(Html.fromHtml())这个方法就可以显示我们选取的效果，但考虑到美观性以及截图保存功能、图片的正常显示，我选取用WebView来加载获取的网页内容。 这里我是这样处理的：首先在本地assets文件夹下创建一个html页面，在页面里加载基本的显示内容并添加css标签修饰加载的内容，当获取到网页内容时，用JavaScript动态替换本地html页面指定的对应标签内容为获取的网页内容，并在本地html页面里对显示内容进行修饰。 看下代码：1234567891011121314151617181920webView.loadUrl(&quot;file:///android_asset/generate_pic.html&quot;);public void changeDay(String strData,String userInfo,String userName,String other) &#123; if(userInfo == null) userInfo =&quot;&quot;; if(strData == null) strData =&quot;&quot;; if(userName == null) userName =&quot;&quot;; if(other == null) other =&quot;&quot;; strData+=&quot;&lt;br /&gt;&lt;br /&gt;\\n&quot; + &quot;\\t\\t&lt;span style=\\&quot;font-size: small;color: gray;line-height:150%;\\&quot;&gt;&quot;+userInfo+&quot;&lt;/span&gt;\\n&quot; + &quot;\\t\\t&lt;br /&gt;&lt;br /&gt;\\n&quot; + &quot;\\t\\t&lt;hr style=\\&quot;margin: auto;border:0;background-color:gray;height:1px;\\&quot;/&gt;\\n&quot; + &quot;\\t\\t&lt;br /&gt;\\n&quot; + &quot;\\t\\t&lt;p style=\\&quot;color: orangered;font-size: x-small;text-align: center;letter-spacing: 0.5px;\\&quot;&gt;由&lt;strong&gt;&quot;+userName+&quot;&lt;/strong&gt;发送 &quot;+other+&quot;&lt;/p&gt;&quot;; webView.loadUrl(&quot;javascript:changeContent(\\&quot;&quot; + strData.replace(&quot;\\n&quot;, &quot;\\\\n&quot;).replace(&quot;\\&quot;&quot;, &quot;\\\\\\&quot;&quot;).replace(&quot;&apos;&quot;, &quot;\\\\&apos;&quot;) + &quot;\\&quot;)&quot;); webView.setBackgroundColor(Color.WHITE); &#125; 白色和黑色不同的显示效果实现可以在changeDay方法里改变css样式来实现，比较简单。 但这里出现了一个问题：当选取的页面内容有图片且图片是以相对路径显示的时候就加载不到图片了。 在这种情况下图片是相对路径也就是在本地对应的相对路径下找，本地肯定是找不到的，图片也就显示不出来。为了让图片正常显示出来，在选取内容页面调用onLoadResource方法对加载的资源进行判断，将图片路径保存下来，因为既然选取页面图片可以显示处理，说明路径是http路径，可以显示图片。看下代码：1234567891011mWebView.setWebViewClient(new WebViewClient()&#123; @Override public void onLoadResource(WebView view, String url) &#123; //Log.e(&quot;TAG&quot;,&quot;url :&quot;+url); if(url.toLowerCase().contains(&quot;.jpg&quot;) ||url.toLowerCase().contains(&quot;.png&quot;) ||url.toLowerCase().contains(&quot;.gif&quot;))&#123; mlistPath.add(url); &#125; super.onLoadResource(view, url); &#125; 当显示选取内容页面显示时动态修改显示的图片路径，让图片显示出来： 1234567891011121314151617181920webView.setWebViewClient(new WebViewClient()&#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; //view.loadUrl(url); return true; &#125; public WebResourceResponse shouldInterceptRequest(WebView view, String url) &#123; WebResourceResponse response = null; for (String path:WebViewHelper.getInstance().getAllListPath())&#123; if (path.toLowerCase().contains(url.replace(&quot;file://&quot;,&quot;&quot;).toLowerCase()))&#123; try &#123; response = new WebResourceResponse(&quot;image/png&quot;, &quot;UTF-8&quot;, new URL(path).openStream()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return response; &#125; &#125;); 这样，我们的图片就可以显示出来啦！最后，实现我们的截图保存功能，看下代码：123456789101112131415161718192021/** * 截屏 * * @return */ public Bitmap getScreen() &#123; Bitmap bmp = Bitmap.createBitmap(webView.getWidth(), 1, Bitmap.Config.ARGB_8888); int rowBytes = bmp.getRowBytes(); bmp = null; if (rowBytes*webView.getHeight()&gt;=getAvailMemory())&#123; return null; &#125; bmp = Bitmap.createBitmap(webView.getWidth(), webView.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bmp); webView.draw(canvas); return bmp; &#125; private long getAvailMemory() &#123; return Runtime.getRuntime().maxMemory(); &#125; 这里需要对保存的图片大小做下判断，防止创建图片过大OOM。 到这里，基本功能就已经实现了。把图片分享给好友吧~ 项目地址: https://github.com/zhangke3016/GeneratePicture 欢迎star、issues~","tags":[{"name":"android","slug":"android","permalink":"https://zhangke3106.github.io/tags/android/"},{"name":"android进阶","slug":"android进阶","permalink":"https://zhangke3106.github.io/tags/android进阶/"}]},{"title":"两行代码搞定Android视图扩散切换效果","date":"2017-01-19T04:14:09.000Z","path":"2017/01/19/两行代码搞定Android视图扩散切换效果/","text":"用最简单的方式来实现Android视图扩散切换效果。 一、概述这两天时间动手撸了个视图扩散切换效果的控制器，API兼容至Android4.0，更方便我们在视图切换过程中有炫酷的过渡效果。本来是想实现两个View之间的过渡动画，实现的过程中想到之前写的Activity切换动画，就试着加上了对Activity切换的动画支持。先来看看效果吧，代码实现只需一行，感觉还不错～ 二、实现思路简单阐述关于过渡动画的实现，我们先简单分解下这个效果，首先，当Activity发生跳转时我们要先获取共享元素控件，在跳转的界面将其添加在跳转页面之上，关于控件位置的获取，在上一篇文章Android碎裂的粒子效果一文中进行了介绍，主要是通过如下方法获取其位置：12345protected Rect getRectInWindow(View view, boolean mIsFullWindow)&#123; int[] location = new int[2]; view.getLocationInWindow(location); return new Rect(location[0],location[1],location[0]+view.getMeasuredWidth(),location[1]+view.getMeasuredHeight()); &#125; 当跳转至目标页面，我们现在其上方盖上一层遮罩，遮罩为我们自定义的控件，在控件上方绘制上一个页面的过渡视图，将其旋转、平移、或者缩放操作： 123456789canvas.save();Matrix matrix = new Matrix();matrix.postTranslate(mRect.left ,mRect.top);matrix.postScale(mScaleXCanvas,mScaleYCanvas,mRect.centerX(),mRect.centerY());matrix.postRotate(mRotationCanvas,mRect.centerX(),mRect.centerY());canvas.concat(matrix);mView.draw(canvas);canvas.restore(); 最后就是圆形散开效果了，这里我在自定义控件上使用的是Xfermode，不断drawCircle并扩大半径，最终显示出跳转页面视图并将遮罩移除。记得关闭硬件加速。 12mClearPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));setLayerType(LAYER_TYPE_SOFTWARE,null); 返回动画同理，在界面返回前将遮罩盖在上一个页面之上，遮罩包括当前页面的视图影像，不断drawCircle并缩小其半径，同时减小当前页面视图的透明度，最终平滑的显示出上一个页面并移除遮罩。 三、具体使用1234567891011121314151617181920212223242526272829303132333435363738 helper = new BaseViewHelper .Builder(SecondActivity.this) //.setEndView()//如果是两个切换的视图 这里设定最终显示的视图 .setTranslationView(v)//设置过渡视图 .isFullWindow(true)//是否全屏显示 .isShowTransition(true)//是否显示过渡动画 .setDimColor(Color.WHITE)//遮罩颜色 .setDimAlpha(200)//遮罩透明度 //.setTranslationX(0)//x轴平移 //.setRotation(360)//旋转 //.setScaleX(0)//x轴缩放 //.setScaleY(0)//y轴缩放 //.setTranslationY(0)//y轴平移 //.setDuration(800)//过渡时长 //.setInterpolator(new AccelerateDecelerateInterpolator())//设置插值器 //设置监听// .setOnAnimationListener(new BaseViewHelper.OnAnimationListener() &#123;// @Override// public void onAnimationStartIn() &#123;// Log.e(&quot;TAG&quot;,&quot;onAnimationStartIn&quot;);// &#125;//// @Override// public void onAnimationEndIn() &#123;// Log.e(&quot;TAG&quot;,&quot;onAnimationEndIn&quot;);// &#125;//// @Override// public void onAnimationStartOut() &#123;// Log.e(&quot;TAG&quot;,&quot;onAnimationStartOut&quot;);// &#125;//// @Override// public void onAnimationEndOut() &#123;// Log.e(&quot;TAG&quot;,&quot;onAnimationEndOut&quot;);// &#125;// &#125;) .create();//开始动画 如果从A页面跳转至B页面，也就是Activity之间的跳转时，在A页面如下代码 : 123new BaseViewHelper .Builder(MainActivity.this, view) .startActivity(intent); B页面代码： 12345678910111213141516helper = new BaseViewHelper .Builder(SecondActivity.this) .isFullWindow(true)//是否全屏显示 .isShowTransition(true)//是否显示过渡动画 .setDimColor(Color.WHITE)//遮罩颜色 .setDimAlpha(200)//遮罩透明度 .create();//开始动画 @Override public void onBackPressed() &#123; if (helper!=null &amp;&amp; helper.isShowing())&#123; helper.backActivity(this); &#125;else &#123; super.onBackPressed(); &#125; &#125; 如果在一个页面两个视图之间跳转，即A视图切换到B视图：在当前页面代码： 123456789101112131415 View v = View.inflate(this,R.layout.layout_second,null); //显示在当前页面跳转 helper = new BaseViewHelper.Builder(this,view) .setEndView(v) .create();@Overridepublic void onBackPressed() &#123; if (helper!=null &amp;&amp; helper.isShowing())&#123; helper.back(); &#125;else &#123; super.onBackPressed(); &#125;&#125; 四、源码地址 项目地址：https://github.com/zhangke3016/ViewSpreadTranslationController如果喜欢，欢迎star、fork、issues。","tags":[{"name":"android","slug":"android","permalink":"https://zhangke3106.github.io/tags/android/"},{"name":"android进阶","slug":"android进阶","permalink":"https://zhangke3106.github.io/tags/android进阶/"}]},{"title":"更快实现Android多级树形选择列表","date":"2017-01-18T14:59:34.000Z","path":"2017/01/18/更快实现Android多级树形选择列表/","text":"快速实现Android多级树形列表，这个库是在鸿洋多级树形列表demo中修改而来。 解决的问题： 支持ID为int类型和String类型。 支持多级复选框选中，使用只需一行代码。 支持动态更新数据并保持原有展开/关闭状态。 支持ListView、RecyclerView。 项目地址：https://github.com/zhangke3016/MultilevelTreeList 一、概述这几天项目中有一个多级列表的菜单，最开始给我的感觉应该就是嵌套ListView,或者用ExpandableListView，但问题是ExpandableListView只支持两级列表，而且关键的是具体分几级是不确定的，也就是可能一级，可能多级，这要是五六级嵌套ListView，想想那酸爽。。。最终在偷懒心态的驱使下到网上查查看有没有类似的，也确实查到鸿洋大佬之前写的一篇关于实现Android多级树形列表的文章，实现很巧妙，使用一个ListView就可以实现多级列表效果，就download下demo，在demo基础上做了部分修改，功能顺利实现。 其实到这里应该就结束了，但使用过程中遇到的一些问题让我觉得这个可以进一步优化，比如我要做个多级复选列表，每次处理子级选中与父级选中搞得很累，生怕哪个递归错了。而且在新增数据的时候刷新页面也需要自己处理，直接刷新没有效果，再加上现在RecyclerView已经用的越来越多了。就想着在周末好好总结下，封装个方便使用的库，方便下一次有类似需求的时候使用。说到底，还是为了下次可以偷偷懒呗。如果小伙伴有类似需求，也可以直接拿来用~ 先看下效果吧： 这篇文章主要介绍这个库如何使用，如果对具体实现细节感兴趣，可以查看源码或者搜索鸿洋的博客。 二、具体使用我们关联列表树需要有三个必须元素，当前id、父级id即pid，显示的内容。id和pid可以为int或者String以及其他类型。要显示的内容需要包装一下： 12//id pid name FileNode为实际用的实体Bean对象mlist.add(new Node(&quot;223&quot;,&quot;0&quot;,&quot;我也是添加的root节点&quot;,new FileNode())); 对于ListView，需要继承自TreeListViewAdapter,如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class SimpleTreeAdapter extends TreeListViewAdapter&#123; public SimpleTreeAdapter(ListView mTree, Context context, List&lt;Node&gt; datas, int defaultExpandLevel, int iconExpand, int iconNoExpand) &#123; super(mTree, context, datas, defaultExpandLevel, iconExpand, iconNoExpand); &#125; public SimpleTreeAdapter(ListView mTree, Context context, List&lt;Node&gt; datas, int defaultExpandLevel) &#123; super(mTree, context, datas, defaultExpandLevel); &#125; @Override public View getConvertView(final Node node , int position, View convertView, ViewGroup parent) &#123; final ViewHolder viewHolder ; if (convertView == null) &#123; convertView = mInflater.inflate(R.layout.list_item, parent, false); viewHolder = new ViewHolder(); viewHolder.cb = (CheckBox) convertView .findViewById(R.id.cb_select_tree); viewHolder.label = (TextView) convertView .findViewById(R.id.id_treenode_label); viewHolder.icon = (ImageView) convertView.findViewById(R.id.icon); convertView.setTag(viewHolder); &#125; else &#123; viewHolder = (ViewHolder) convertView.getTag(); &#125; viewHolder.cb.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; setChecked(node,viewHolder.cb.isChecked()); &#125; &#125;); if (node.isChecked())&#123; viewHolder.cb.setChecked(true); &#125;else &#123; viewHolder.cb.setChecked(false); &#125; if (node.getIcon() == -1) &#123; viewHolder.icon.setVisibility(View.INVISIBLE); &#125; else &#123; viewHolder.icon.setVisibility(View.VISIBLE); viewHolder.icon.setImageResource(node.getIcon()); &#125; viewHolder.label.setText(node.getName()); return convertView; &#125; private final class ViewHolder &#123; ImageView icon; CheckBox cb; TextView label; &#125;&#125; 对于RecyclerView，需继承自TreeRecyclerAdapter,如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class SimpleTreeRecyclerAdapter extends TreeRecyclerAdapter &#123; public SimpleTreeRecyclerAdapter(RecyclerView mTree, Context context, List&lt;Node&gt; datas, int defaultExpandLevel, int iconExpand, int iconNoExpand) &#123; super(mTree, context, datas, defaultExpandLevel, iconExpand, iconNoExpand); &#125; public SimpleTreeRecyclerAdapter(RecyclerView mTree, Context context, List&lt;Node&gt; datas, int defaultExpandLevel) &#123; super(mTree, context, datas, defaultExpandLevel); &#125; @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; return new MyHoder(View.inflate(mContext, R.layout.list_item,null)); &#125; @Override public void onBindViewHolder(final Node node, RecyclerView.ViewHolder holder, int position) &#123; final MyHoder viewHolder = (MyHoder) holder; //todo do something viewHolder.cb.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; setChecked(node,viewHolder.cb.isChecked()); &#125; &#125;); if (node.isChecked())&#123; viewHolder.cb.setChecked(true); &#125;else &#123; viewHolder.cb.setChecked(false); &#125; if (node.getIcon() == -1) &#123; viewHolder.icon.setVisibility(View.INVISIBLE); &#125; else &#123; viewHolder.icon.setVisibility(View.VISIBLE); viewHolder.icon.setImageResource(node.getIcon()); &#125; viewHolder.label.setText(node.getName()); &#125; class MyHoder extends RecyclerView.ViewHolder&#123; public CheckBox cb; public TextView label; public ImageView icon; public MyHoder(View itemView) &#123; super(itemView); cb = (CheckBox) itemView .findViewById(R.id.cb_select_tree); label = (TextView) itemView .findViewById(R.id.id_treenode_label); icon = (ImageView) itemView.findViewById(R.id.icon); &#125; &#125;&#125; 初始化：ListView:123456789//第一个参数 ListView//第二个参数 上下文//第三个参数 数据集//第四个参数 默认展开层级数 0为不展开//第五个参数 展开的图标//第六个参数 闭合的图标 mAdapter = new SimpleTreeAdapter(mTree, ListViewActivity.this, mDatas, 1,R.mipmap.tree_ex,R.mipmap.tree_ec); mTree.setAdapter(mAdapter); RecyclerView： 12345678910//第一个参数 RecyclerView//第二个参数 上下文//第三个参数 数据集//第四个参数 默认展开层级数 0为不展开//第五个参数 展开的图标//第六个参数 闭合的图标mAdapter = new SimpleTreeRecyclerAdapter(mTree, RecyclerViewActivity.this, mDatas, 1,R.mipmap.tree_ex,R.mipmap.tree_ec);mTree.setAdapter(mAdapter); 添加数据，可以保持原有选中或者展开状态：123List&lt;Node&gt; mlist = new ArrayList&lt;&gt;(); mlist.add(new Node(&quot;223&quot;,&quot;0&quot;,&quot;我也是添加的root节点&quot;,new FileNode())); mAdapter.addData(0,mlist); 获取选中内容：如果node的isChecked()为true，即为选中状态。 123456789101112StringBuilder sb = new StringBuilder(); //获取排序过的nodes //如果不需要刻意直接用 mDatas既可 final List&lt;Node&gt; allNodes = mAdapter.getAllNodes(); for (int i = 0; i &lt; allNodes.size(); i++) &#123; if (allNodes.get(i).isChecked())&#123; sb.append(allNodes.get(i).getName()+&quot;,&quot;); &#125; &#125; String strNodesName = sb.toString(); if (!TextUtils.isEmpty(strNodesName)) Toast.makeText(this, strNodesName.substring(0, strNodesName.length()-1),Toast.LENGTH_SHORT).show(); 控制父子之间联动的选中与取消状态，只需调用setChecked方法既可，注意如果在setOnCheckedChangeListener中处理会有问题：因为如果要子节点/父节点选中或者取消需要刷新页面，而刷新页面又会触发viewHolder.cb.setChecked(true/false);的判断从而又会进入setOnCheckedChangeListener，会导致如果父节点选中某些子节点取消不了的情况。 1234567//viewHolder.cb 为CheckBoxviewHolder.cb.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; setChecked(node,viewHolder.cb.isChecked()); &#125; &#125;); 三、简单介绍通过一个ListView来展示所有数据，每一级内容的显示根据当前展示数据的等级缩进一定的padding值，让我们看起来有缩进效果。 使用过程中感觉不是很舒服的地方在于最终用于显示在界面实体Bean并不是我们传进去的数据，而是经过转化并且过滤的数据，这样最直接的影响就是在我新增数据的数据之后，拿着Adapter来刷新的时候，并没有任何效果。因为我们没有将后面新加的数据进行转化。 而我们如何能在不改变原有数据结构的基础上，添加我们的新内容，并保持原有的选中或者展开正常呢？我的想法是这样的，如果可以直接给它传入转化后的Node节点类型数据就好了，我想到了继承，让实体类去继承基类Node，但一旦继承Node则意味着实体类就不能再继承其他类了，感觉不是很灵活，而且也影响了实体类本身的结构。后来想到了包装设计模式的一些东西，那我就在实体类外再包上一层，也就是将实体类传给Node，最终我们使用的还是Node，但也可以用node.bean很轻松的取出实体类做其他操作，并且实体类本身的结构并没有被破坏。 在此基础上，因为我们的Node不需要转化重新创建，那么它就可以保存一些状态比如展开、选中等等，而在新加入数据时只需标记下新加入的数据，只需对新加入的数据进行初始化状态，已有老数据不进行状态改变: 123if (node.isNewAdd &amp;&amp; defaultExpandLeval &gt;= currentLevel) &#123; node.setExpand(true); &#125; 这样，我们可以保持动态更新添加数据又可以保持原有的展开或选中状态不发生变化，实现我们的需求。 四、源码 项目地址：https://github.com/zhangke3016/MultilevelTreeList","tags":[{"name":"android","slug":"android","permalink":"https://zhangke3106.github.io/tags/android/"}]}]